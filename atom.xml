<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://imenghu.github.io</id>
    <title>i萌虎</title>
    <updated>2019-11-22T06:54:17.473Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://imenghu.github.io"/>
    <link rel="self" href="https://imenghu.github.io/atom.xml"/>
    <logo>https://imenghu.github.io/images/avatar.png</logo>
    <icon>https://imenghu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, i萌虎</rights>
    <entry>
        <title type="html"><![CDATA[【Python】 命名空间与LEGB规则]]></title>
        <id>https://imenghu.github.io/post/python-ming-ming-kong-jian-yu-legb-gui-ze</id>
        <link href="https://imenghu.github.io/post/python-ming-ming-kong-jian-yu-legb-gui-ze">
        </link>
        <updated>2019-11-22T06:39:37.000Z</updated>
        <content type="html"><![CDATA[<p>■　　命名空间</p>
<p>所谓命名空间，就是指根据代码区域的不同而对变量名做出的划分，在一个命名空间中往往会有一定的变量名和变量内容的对应关系。在值语义的语言中，变量名往往是变量所指代内容在内存中地址的别称，但是在python中，变量名本身就是一个字符串对象，命名空间只不过是把这个字符串对象和对象对应了起来。进一步来说，其实在python中的命名空间就是一个字典，记录了该空间中所有变量名和变量内容的对应。后面会提到如何调用这个字典来查看命名空间。</p>
<p>■　　LEGB规则</p>
<p>LEGB是指python中命名空间的四个从低到高不同的层次，分别是Local , Enclosing , Global , Built-in。local指一个函数或者方法的内部的空间，enclosing指的是闭包内部空间，global是整个脚本的全局空间，而built-in是指python最上层的系统自带的一些名字的空间。</p>
<p>因为python可以提供这么多不同层次的命名空间，所以当我们在程序中写下一个变量名的时候，解释器就会通过一定的顺序来查找这个变量名的具体内容。这个顺序显然就是local --&gt; enclosing --&gt; global --&gt; built-in。如果按照此顺序逐级而上却没有找到相关的变量名的内容的话就表明这个变量名在哪一级命名空间中都不存在，程序就会raise起一个NameError了。</p>
<p>因为命名空间是可以互相嵌套的，所以在程序中如果碰到很多同名的变量的话，很可能会由于命名关系的问题而使得程序不像我们所想得那样运行。</p>
<p>●  local和global命名空间<br>
　　最常见的命名空间的关系是local和global之间的：</p>
<pre><code class="language-python">var = &quot;global var&quot;
def test():
    var = &quot;local var&quot;
    print var
test()
print var
#结果
#local var
#global var

</code></pre>
<p>显而易见，函数def中的var是个局部命名空间中的变量，所以函数中print var时解释器在局部命名空间中就已经找到了相关的变量名。另一方面在函数外面print var的时候，此时的var属于程序的global命名空间中且其下面的小命名空间中没有相关的变量名定义，最终解释器只能到global命名空间之中去找到这个变量名。假如把函数中的var = &quot;local var&quot;给注释掉那么显然结果会变成两行的global var因为在函数里面的时候解释器也一直到global的命名空间中才找到变量名。另一方面，如果确实想要在函数中对全局变量var做出一定修改的话那么可以用global关键字来声明某个变量必须查找global的命名空间而不是其下层的命名空间。比如：</p>
<pre><code class="language-python">var = &quot;global var&quot;
def test():
    global var
    var = &quot;local var&quot;
    print var
test()
print var
#结果
#local var
#local var
</code></pre>
<p>因为对于解释器来说，下层的命名空间可以覆盖上层命名空间的内容，而同一层级的命名空间中新的内容又可以覆盖旧的变量的内容，所以在实际工作中要注意到命名空间的变化问题。比如在from module import *这种操作的时候就要当心，因为把一个模块中所有变量名导入到全局命名空间中有可能会把目前存在于命名空间中的一些同名变量给覆盖掉的。</p>
<p>● enclosing命名空间<br>
　　闭包空间在local和global之间，主要用于在面向函数编程的过程中出现的闭包的情况。比如下面这段代码：</p>
<pre><code class="language-python">var = 'global value'
def outer():
    var = 'enclosed value'
    def inner():
        var = 'local value'
        print(var)
    inner()
outer()
#结果
#local value
</code></pre>
<p>如果把var = 'local value'这句给注释掉那么结果就变成了enclosed value，进一步把var = 'enclosed value'也注释掉那结果就变成了global value了。这一切看起来都是显而易见的。</p>
<p>和global命名空间类似的，位于enclosed命名空间包裹中的变量名也可以通过关键字来指定其不搜索local，而直接搜索enclosed级别的命名空间。这个关键字是nonlocal。nonlocal目前只能在python3.x中使用，python2.x还不能使用。</p>
<p>●  built-in命名空间<br>
python自带很多函数和变量，这些对象的名字都是属于内建命名空间的。假如我们想要自定义一个重名的变量，那么就会对内建空间的变量做出覆盖。比如我可以自定义一个len函数来覆盖掉python原本的len函数。虽然可以这么做，但是不推荐，私自覆盖built-in命名空间的内容可能会引起意想不到的后果，比如在后续的函数调用中可能在我们想不到的某个第三方库中调用了len函数的话就会引起混乱了。</p>
<p>●  命名空间内容的查看<br>
python自带了locals()和globals()两个函数，分别返回调用此函数的当前位置所在的local命名空间中所有变量名和值的关系（以字典的形式）以及global命名空间中所有变量名和值的关系。例如：</p>
<pre><code class="language-python">var1 = 1
def test():
    var2 = 2
    print locals()
    print globals()
test()
#结果
#{'var2': 2}
#{'var1': 1, '__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__file__': 'D:/PycharmProjects/TestProject/test.py', '__package__': None, 'test': &lt;function test at 0x000000000383FB38&gt;, '__name__': '__main__', '__doc__': None}
</code></pre>
<p>■　　一些补充</p>
<p>以上说到的包括命名空间也好，LEGB规则也好，借助常识和在其他语言中得到的知识，在实际应用过程中稍微脑补一下总还是能解决的。但是python中有时候也有一些出人意料的情况（至少目前对我来说是这样，我还没办法找到清晰自洽的说法来解释这些出人意料）。下面针对这些情况做出说明，这也是这篇文章的重要之处。</p>
<p>●  不要轻易到下层命名空间中去改变全局变量的值<br>
　　虽然前面说到了，通过global关键字的提前声明可以在函数中也对全局变量做出修改，但是这不是很好。会引起很多乱七八糟的错误，解决的一个方法是通过函数参数的形式把全局变量的值传递到函数中来，然后返回通过函数处理后的值。函数定义结束后回到global命名空间之后在调用函数，以返回值赋值给全局变量：</p>
<pre><code class="language-ptthon">var = 1
def test():
  global var
  var = 2
test()
####上面这样不好，改成下面这样####
var = 1
def test(para):
  para = 2
  return para
var = test(var)
</code></pre>
<p>●  赋值语句的默认行为<br>
　　下面这段代码会报错：</p>
<pre><code class="language-python">var = 1
def test():
    var += 1
test()

#错误信息
#UnboundLocalError: local variable 'var' referenced before assignment
</code></pre>
<p>在一般认知中，var += 1等价于 var = var + 1，这个认识没有问题。但是在python中,赋值语句的默认行为是“只要在当前local命名空间中无同名变量且没有global,nonlocal等关键字的声明的话，就一定创建一个该名字的新局部变量”，然后在进行赋值语句等号右边的运算，把运算所得对象约束到这个局部变量上来。在这个例子中，新建了一个名为var的局部变量，因为var这个名字已经存在于当前的local命名空间中了所以解释器不会再向上层命名空间中去寻找变量。但是这个var在此时还没有具体的对象约束，所以在等号右边运算时导致报错。</p>
<p>如果把上述代码中的var += 1换成var + 1，没有了赋值操作的话，解释器就不会认为var是个新建出来的局部变量，然后查找到全局变量var取它的值来进行运算，这样就不报错了。</p>
<p>另外，如果把var换成另外一种可以通过非赋值手段来改变的类型的话（其实换句话说，就是所有可变类型）：</p>
<pre><code class="language-python">var = [1]
def test():
    var.append(2)
test()
print var
#结果
#[1,2]
</code></pre>
<p>这样子的话，由于避开了创建一个新局部变量的步骤，就可以做到改变全局变量而不报错了。</p>
<p>进一步，一个比较容易混淆的，就是把上面这个例子中的append方法再改成var[0] += 1。这样一个语句乍一看还是一个赋值语句，似乎还是会报错，但是实际上并不。因为它的等号左边不是一个变量名了，通过这个变量名创建一个新局部变量也就无从谈起了。因为它没有办法创建新局部变量，所以也就不会有等号右边变量名存在却没有实际值的变量引起的计算错误了。所以var[0] += 1这个语句最终还是会改变全局变量的var，var从[1]变成了[2]。</p>
<p>●  类中命名空间的特殊性<br>
　　以上说到的命名空间规则，基本上都是在面向函数编程的这个前提下的，在面向对象的编程中，有时候也会遇到一些奇奇怪怪的，类似于命名空间的问题。实际上这些问题应该是属于面向对象机制框架中的一些规律。关于这方面的一些内容我写了一点在python类机制那篇文章中，这里做一点补充。</p>
<p>比如类变量和实例变量之间的命名冲突问题：</p>
<pre><code class="language-python">class Test():
  var = 1
  def __init__(self):
    self.var = 2

t = Test()
print t.var
</code></pre>
<p>在这种情况下因为实例变量存在，所以引用var属性的时候取到的是实例变量的var。但是如果在初始化方法中没有提到self.var的话，那么t.var就直接取向类变量的var。</p>
<p>另一方面，如果在没有实例变量var的情况下，在其他属性方法（除了__init__方法的其他方法）中引用self.var则会指向类变量的var。在有实例变量var的情况下，其他属性方法中的self.var自然是指向实例属性var的。如果实例变量var存在时想要引用类变量var可以通过类名Test.var来引用或者self.<strong>class</strong>.var来引用。</p>
<p>想要提到一点类中命名空间比较特殊的一点，如果把上例代码中的self.var = 2改成self.var += 1，从形式上来说似乎和之前提到过没有用global关键字声明而直接对全局变量进行赋值操作的样子差不多，当时那个情况的结果是报错UnboundLocalError。但是在这里，并不报错。一来，等号左边的self.var本身不是一个变量名，就好比之前提到的var[0] += 1一样，不会创建新的局部变量；二来，在类的属性方法中似乎有一种特别的机制就是会自动把赋值语句等号左边的self.xxx识别成当前实例的一个属性，如果之前没有这个属性就自动创建一个新属性，基于这种推断，在类中的赋值语句中，等号左边如果是self.xxx的话，创建的不是一个新的局部变量而是一个新的实例的属性。从结果来看，这里发生的，是等号右边self.var取到类变量的var，进行+1操作之后赋值给一个新的实例变量的var，自此之后通过这个初始化方法得到的实例就有了一个self.var的实例变量，其值是类变量var+1。由于这种混乱出现的可能，所以在类的方法中想要引用类变量的话请尽量通过类名来引用。比如上面提到的self.var += 1改成Test.var += 1就可以做到每个实例创建后类变量var都+1。</p>
<p>●  for循环的变量名会污染外部命名空间<br>
　　在c，java里面，for循环的第一子句中可以声明一个仅限本次循环使用的变量比如for(int i,i=0;i&lt;10;i++)这样子，再循环结束之后这个i所占的空间就被释放了。</p>
<p>python中这个for表达式更加简洁 for i in range(10)，但是这里的i是会影响本次循环之后的代码的。也就是说在pythonfor循环语句的循环头中的那个变量不是循环语句中的局部变量，而是会泄露到外部命名空间中的变量：</p>
<pre><code class="language-python">for i in range(10):
    if i == 9:
        print locals()
print locals()
#结果
#{'__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__file__': 'D:/PycharmProjects/TestProject/test.py', '__package__': None, 'i': 9, '__name__': '__main__', '__doc__': None}
#{'__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__file__': 'D:/PycharmProjects/TestProject/test.py', '__package__': None, 'i': 9, '__name__': '__main__', '__doc__': None}
</code></pre>
<p>第二个locals函数返回的命名空间信息中依然存在i是9这一项，表明i这个变量被泄露了出来，污染了外部的命名空间。这点需要注意一下。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈Python类命名空间]]></title>
        <id>https://imenghu.github.io/post/qian-tan-python-lei-ming-ming-kong-jian</id>
        <link href="https://imenghu.github.io/post/qian-tan-python-lei-ming-ming-kong-jian">
        </link>
        <updated>2019-11-21T11:25:52.000Z</updated>
        <content type="html"><![CDATA[<p>前面章节中，已经不只一次提到，所有位于 class 语句中的代码，其实都位于特殊的命名空间中，通常称之为类命名空间。Python 中，编写的整个程序默认处于全局命名空间内，而类体则处于类命名空间内。</p>
<p>Python 允许在全局范围内放置可执行代码，当 Python 执行该程序时，这些代码就会获得执行的机会。类似地，Python 同样允许在类范围内放置可执行代码，当 Python 执行该类定义肘，这些代码同样会获得执行的机会。</p>
<p>例如，如下程序测试了类命名空间：<br>
class Item:</p>
<h1 id="直接在类空间中放置执行性质代码">直接在类空间中放置执行性质代码</h1>
<p>print('正在定义Item类')<br>
for i inrange(10):<br>
if i %2==0:<br>
print('偶数:', i)<br>
else:<br>
print('奇数:', i)<br>
运行结果为：<br>
正在定义Item类<br>
偶数: 0<br>
奇数: 1<br>
偶数: 2<br>
奇数: 3<br>
偶数: 4<br>
奇数: 5<br>
偶数: 6<br>
奇数: 7<br>
偶数: 8<br>
奇数: 9<br>
正如从上面代码所看到的，程序直接在 Item 类体中放置普通的输出语句、循环语句、分支语句，这都是合法的。当程序执行 Item 类时，Item 类命名空间中的这些代码都会被执行。</p>
<p>从执行效果来看，这些可执行代码被放在 Python 类命名空间与全局空间并没有太大的区别。确实如此，这是因为程序并没有定义“成员”（变量或函数），这些代码执行之后就完了，不会留下什么。</p>
<p>但下面代码就有区别。下面代码示范了在全局空间和类命名空间内分别定义 lambda 表达式：<br>
global_fn =lambda p:print('执行lambda表达式，p参数: ', p)<br>
class Category:<br>
cate_fn =lambda p:print('执行lambda表达式，p参数: ', p)</p>
<h1 id="调用全局范围内的global_fn为参数p传入参数值">调用全局范围内的global_fn，为参数p传入参数值</h1>
<p>global_fn('fkit')# ①<br>
c =Category()</p>
<h1 id="调用类命名空间内的cate_fnpython自动绑定第一个参数">调用类命名空间内的cate_fn，Python自动绑定第一个参数</h1>
<p>c.cate_fn()# ②<br>
上面程序分别在全局空间、类命名空间内定义了两个 lambda 表达式，在全局空间内定义的 lambda 表达式就相当于一个普通函数，因此程序使用调用函数的方式来调用该 lambda 表达式，并显式地为第一个参数绑定参数值，如上面程序中 ① 号代码所示。</p>
<p>对于在类命名空间内定义的 lambda 表达式，则相当于在该类命名空间中定义了一个函数，这个函数就变成了实例方法，因此程序必须使用调用方法的方式来调用该 lambda 表达式，Python 同样会为该方法的第一个参数（相当于 self 参数）绑定参数值，如上面程序中 ② 号代码所示。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解读Python编程中的命名空间与作用域]]></title>
        <id>https://imenghu.github.io/post/jie-du-python-bian-cheng-zhong-de-ming-ming-kong-jian-yu-zuo-yong-yu</id>
        <link href="https://imenghu.github.io/post/jie-du-python-bian-cheng-zhong-de-ming-ming-kong-jian-yu-zuo-yong-yu">
        </link>
        <updated>2019-11-21T11:20:16.000Z</updated>
        <content type="html"><![CDATA[<p>变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。<br>
一个Python表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。<br>
每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。<br>
Python会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。<br>
因此，如果要给全局变量在一个函数里赋值，必须使用global语句。<br>
global VarName的表达式会告诉Python， VarName是一个全局变量，这样Python就不会在局部命名空间里寻找这个变量了。</p>
<p>命名空间的定义<br>
Python命名空间是名称到对象的映射，这就像是字典，键名是变量名，值是变量的值。比如：</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = 3<br>
globals()<br>
{'<strong>builtins</strong>': &lt;module '<strong>builtin</strong>' (built-in)&gt;, '<strong>name</strong>': '<strong>main</strong>', '<strong>doc</strong>': None, 'x': 3, '<strong>package</strong>': None}</p>
</blockquote>
</blockquote>
</blockquote>
<p>可以看到变量x，3以字典的形式存放在globals空间内。以之对应的名字空间还有：locals()。</p>
<blockquote>
<blockquote>
<blockquote>
<p>locals()<br>
{'<strong>builtins</strong>': &lt;module '<strong>builtin</strong>' (built-in)&gt;, '<strong>name</strong>': '<strong>main</strong>', '<strong>doc</strong>': None, 'x': 3, '<strong>package</strong>': None}</p>
</blockquote>
</blockquote>
</blockquote>
<p>实际上，你可以通过向名字添加键名和值：</p>
<blockquote>
<blockquote>
<blockquote>
<p>globals()['y'] = 5<br>
y<br>
5</p>
</blockquote>
</blockquote>
</blockquote>
<p>上图左侧是内置命名空间，右侧是不同的模块，有各自的全局命名空间，全局命名空间内定义函数就会有局部命名空间。</p>
<p>命名空间的种类<br>
Python中有三种命名空间：</p>
<p>a) 局部，函数内的命名空间就是局部的；<br>
b) 全局，模块内的命名空间就是全局的；</p>
<p>c) 内置，包括异常类型、内建函数和特殊方法，可以代码中任意地方调用；<br>
下面讨论关于名字空间的搜索顺序，先来看张图：</p>
<figure data-type="image" tabindex="1"><img src="https://img2.mukewang.com/5af99a370001f46803670254.jpg" alt=""></figure>
<p>命名空间的可见性（作用域）</p>
<p>a) 内置命名空间在代码所有位置都是可见的，所以可以随时被调用；</p>
<p>b) 全局命名空间和局部命名空间中， 如果有同名变量，在全局命名空间处，局部命名空间内的同名变量是不可见的；</p>
<p>c) 在局部命名空间处，全局命名空间的同名变量是不可见的（只有变量不同名的情况下，可使用 global关键字让其可见）。</p>
<p>知道了可见性，下面说变量的查找顺序就要清楚多了。</p>
<p>命名空间的查找顺序<br>
a) 如果在函数内调用一个变量，先在函数内（局部命名空间）查找，如果找到则停止查找。否则在函数外部（全局命名空间）查找，如果还是没找到，则查找内置命名空间。如果以上三个命名都未找到，则抛出NameError 的异常错误。<br>
b) 如果在函数外调用一个变量，则在函数外查找（全局命名空间，局部命名空间此时不可见），如果找到则停止查找，否则到内置命名空间中查找。如果两者都找不到，则抛出异常。只有当局部命名空间内，使用global 关键字声明了一个变量时，查找顺序则是 a) 的查找顺序。</p>
<p>为了帮助理解，来举个例子，我们在全局命名空间里定义一个变量money。我们再在函数内给变量money赋值，然后Python会假定money是一个局部变量。然而，我们并没有在访问前声明一个局部变量money，结果就是会出现一个UnboundLocalError的错误。取消global语句的注释就能解决这个问题。</p>
<p>#!/usr/bin/python</p>
<h1 id="-coding-utf-8-">-<em>- coding: UTF-8 -</em>-</h1>
<p>Money = 2000<br>
def AddMoney():</p>
<h1 id="想改正代码就取消以下注释">想改正代码就取消以下注释:</h1>
<h1 id="global-money">global Money</h1>
<p>Money = Money + 1</p>
<p>print Money<br>
AddMoney()<br>
print Money</p>
<p>dir()函数<br>
dir()函数一个排好序的字符串列表，内容是一个模块里定义过的名字。<br>
返回的列表容纳了在一个模块里定义的所有模块，变量和函数。如下一个简单的实例：<br>
#!/usr/bin/python</p>
<h1 id="-coding-utf-8--2">-<em>- coding: UTF-8 -</em>-</h1>
<h1 id="导入内置math模块">导入内置math模块</h1>
<p>import math</p>
<p>content = dir(math)</p>
<p>print content;</p>
<p>以上实例输出结果：<br>
['<strong>doc</strong>', '<strong>file</strong>', '<strong>name</strong>', 'acos', 'asin', 'atan',<br>
'atan2', 'ceil', 'cos', 'cosh', 'degrees', 'e', 'exp',<br>
'fabs', 'floor', 'fmod', 'frexp', 'hypot', 'ldexp', 'log',<br>
'log10', 'modf', 'pi', 'pow', 'radians', 'sin', 'sinh',<br>
'sqrt', 'tan', 'tanh']</p>
<p>在这里，特殊字符串变量__name__指向模块的名字，__file__指向该模块的导入文件名。</p>
<p>globals()和locals()函数</p>
<pre><code>根据调用地方的不同，globals()和locals()函数可被用来返回全局和局部命名空间里的名字。
如果在函数内部调用locals()，返回的是所有能在该函数里访问的命名。
如果在函数内部调用globals()，返回的是所有在该函数里能访问的全局名字。
两个函数的返回类型都是字典。所以名字们能用keys()函数摘取。
</code></pre>
<p>reload()函数<br>
当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。<br>
因此，如果你想重新执行模块里顶层部分的代码，可以用reload()函数。该函数会重新导入之前导入过的模块。语法如下：<br>
reload(module_name) 厦工叉车<br>
在这里，module_name要直接放模块的名字，而不是一个字符串形式。比如想重载hello模块，如下：<br>
reload(hello)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[windows常用cmd命令]]></title>
        <id>https://imenghu.github.io/post/windows-chang-yong-cmd-ming-ling</id>
        <link href="https://imenghu.github.io/post/windows-chang-yong-cmd-ming-ling">
        </link>
        <updated>2019-11-21T08:47:29.000Z</updated>
        <content type="html"><![CDATA[<p>windows常用cmd命令</p>
<ul>
<li>常用基本命令</li>
<li>辅助符号或命令</li>
<li>常用工具</li>
<li>验证考核<br>
常用基本命令：netstat，find，ping，cd，辅助符号或命令：Ctrl+C、cls、|、&gt;、向上的箭头键等，常用工具: Process Explorer。</li>
</ul>
<p>建议掌握这些命令获取帮助的方式，一般都是 ”命令 /?“ 或者“命令 -help”，如“cd /?”，能看懂命令帮助提示(根据帮助尝试使用)。</p>
<p>常用基本命令<br>
1，列出所有任务及进程号，杀进程</p>
<pre><code> tasklist

 tasklist /?  获取使用帮助

 taskkill

 taskkill /?  获取使用帮助
</code></pre>
<p>2，cd 切换目录</p>
<pre><code> cd /？ 获取使用帮助

 跳转到当前驱动器的根目录

      cd [当前驱动器盘符]:\    例如： cd c:\ ，或者更简单的   cd\

 跳转到当前驱动器的其他文件夹

      以C盘下的WINDOWS文件夹为例，输入：cd C:\WINDOWS

 跳转到其他驱动器

      以从C盘跳转到D盘为例 在任意目录下直接输入：  D:

 跳转到其他驱动器的其他文件夹

      假设当前在C盘，要跳转到E的software目录    cd /d e:\software

      注意此处必须加/d参数。否则无法跳转。

 跳转到上一层目录

      cd..
</code></pre>
<p>3，netstat 查看网络连接状态</p>
<pre><code> 显示协议统计信息和当前 TCP/IP 网络连接。该命令可以查看当前机器建立的所有网络链接状态，以及对应哪个进程。

 netstat -help 获取命令行使用帮助信息

 例子:netstat -ano  查看网络连接、状态以及对应的进程id
</code></pre>
<p>4，find</p>
<pre><code> 常用于某个命令输出结果太多，需要模糊搜索我们关心的内容时使用，一般辅助|使用（|代表前一个输出作为后一个的输入）

 find /？获取使用帮助

 如果是linux就是grep，搜索特定字符

 例子：netstat -ano|find &quot;.8&quot;
</code></pre>
<p>5，ping</p>
<pre><code> ping -help
</code></pre>
<p>6，tracert</p>
<pre><code> tracert也被称为Windows路由跟踪实用程序，在命令提示符（cmd）中使用tracert命令可以用于确定IP数据包访问目标时所选择的路径。

 tracert /? 获取使用帮助

 例子：tracert www.baidu.com
</code></pre>
<p>辅助符号或命令<br>
7，“|”cmd命令中|代表前一个的输出代表后一个的输入</p>
<pre><code> 查找特定ip的网络连接及进程号：netstat -ano|find &quot;192.168.1.10&quot;  
</code></pre>
<p>8，重定向输出符号&gt; &gt;&gt;</p>
<pre><code> 将原本输出到命令窗口的内容，转存到文件中，如jstack 12912 &gt;d:/s.txt  打印线程到指定文件

 cmd &gt;重定向输出并覆盖源文件。

      例如

      echo hello &gt;c:\1.txt

      1.txt的文件内容先被清空，然后写入hello。

 cmd &gt;&gt;重定向输出追加到文件末尾

      例如：

      echo hello &gt;c:\1.txt

      在1.txt文件末尾加上hello
</code></pre>
<p>9，重定向输入符号&lt; &lt;&lt;</p>
<pre><code> cmd &lt; file

      使cmd命令从file读入

 cmd &lt;&lt; text

      从命令行读取输入，直到一个与text相同的行结束。除非使用引号把输入括起来，此模式将对输入内容进行shell变量替换。如果使用 &lt;&lt;- ，则会忽略接下来输入行首的tab，结束行也可以是一堆tab再加上一个与text相同的内容，可以参考后面的例子。

 cmd &lt;&lt;&lt; word

      把word（而不是文件word）和后面的换行作为输入提供给cmd。

 cmd &lt;&gt; file

      以读写模式把文件file重定向到输入，文件file不会被破坏。仅当应用程序利用了这一特性时，它才是有意义的。

 cmd &gt;| file

      功能同&gt;，但即便在设置了noclobber时也会覆盖file文件，注意用的是|而非一些书中说的!，目前仅在csh中仍沿用&gt;!实现这一功能。 
</code></pre>
<p>10，终止一直在运行的命令ctrl+c</p>
<pre><code> 有时某个命令一直打印输出结果(如ping 192.168.1.10 -t)，我们想终止这个命令的执行，直接按ctrl+c即可。
</code></pre>
<p>11，清空cmd窗口内容命令cls</p>
<pre><code> 有时cmd内容太多，滚动费尽，需要清空屏幕内容，直接输入cls即可
</code></pre>
<p>12，cmd命令中，按键盘的向上箭头可以直接复制前一个命令</p>
<p>常用工具<br>
13，常用工具</p>
<pre><code> Process Explorer，查询进程的详细信息，如查询java进程启动参数，运行环境，线程信息、网络连接信息、使用了哪些dll，打开了什么句柄。包含注册表、Socket、文件等等。

 下载地址：https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://imenghu.github.io/post-images/1574326094006.png" alt=""></figure>
<p>验证考核<br>
1，浏览器访问任何一个域名网站（如百度），然后使用cmd命令查找到本机到这个网站的网络连接状态</p>
<pre><code> 2，持续ping100次www.baidu.com,并且输出到d:/pingbaidu.txt

 3，假如不通过环境变量中的java相关命令如jps、java， 而是希望使用你机器上装的某个版本jdk中命令jstack.exe（如装在D:\Program Files\java\jdk1.8.0_101），你会怎么做？

 4，你机器上已经启动了一个smartbi，请告知如何确认jvm所有启动参数</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[javascript 作用域详解]]></title>
        <id>https://imenghu.github.io/post/javascript-zuo-yong-yu-xiang-jie</id>
        <link href="https://imenghu.github.io/post/javascript-zuo-yong-yu-xiang-jie">
        </link>
        <updated>2019-11-19T06:58:14.000Z</updated>
        <content type="html"><![CDATA[<p>作用域理解：定义的变量、函数生效的范围。javascript 有全局作用域和函数作用域两种。</p>
<p>注：es6实现let 块级作用域不是js原生的，底层同样是通过var实现的。如果想了解具体细节，请访问babel官方 对es6中let 进行解析。</p>
<p>执行上下文<br>
范围：一段内或者一个函数内；<br>
全局：函数声明、变量声明 。范围：；<br>
函数：函数声明、变量声明、this、arguments。范围：一个函数内部；</p>
<p><strong>函数、变量声明提升</strong></p>
<pre><code class="language-javascript">&lt;script&gt;

        foo(); //打印a

        var foo = 1;

        function foo (){

            console.log(’a‘)

        }；

        console.log(foo); //1

&lt;/script&gt;

//实际的执行顺序为

&lt;script&gt;

        function foo(){  //函数声明优先于变量的声明

            console.log(&quot;a&quot;);

        }

        //var a ;  重复声明，这儿被省略了。

        foo(); //打印a

        foo = 1;  //给foo赋值为1

        console.log(foo); //1

&lt;/script&gt;
</code></pre>
<p>当js引擎执行一个 执行上下文代码块时，执行顺序为：</p>
<ol>
<li>函数声明 function a(){};(函数优先) 注：let a = function (){}; 这是变量的声明和赋值，不是函数的声明。</li>
<li>变量声明 var a; 注：刚开始只对变量进行声明，没有进行赋值，如果 在赋值之前使用到这个变量 值为：undefined。</li>
<li>执行上下文为函数作用域时：确定this和arguments。</li>
<li>按照js单线程和异步策略依次执行 作用域中的代码。</li>
</ol>
<p>我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题！</p>
<p><strong>作用域链</strong><br>
自由变量：当前作用域没有定义的变量，但是上层作用域定义了，可以在此层作用域中使用的变量。<br>
作用域链：当使用一个变量时候，先在自己的作用域里找，如果没有找到，再到父级作用域找，一直找到全局作用域，如果都没有找到即报错。</p>
<p><strong>块级作用域</strong><br>
js无块级作用域，仅有全局作用域和函数作用域两种作用域。<br>
ES6 通过对全局作用域的特殊实现，实现了js的块级作用域 let；<br>
let 的生效范围为 { }；<br>
const 为定义常量。注：定义的常量的值存储的内存地址不可变动，值是可变的比如常量中定义的是数组 或者对象时候，可以通过数组或对象方法操作原数据，只要不重新赋值就没问题</p>
<center>-END-</center>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python中的类属性和对象属性的作用域]]></title>
        <id>https://imenghu.github.io/post/python-zhong-de-lei-shu-xing-he-dui-xiang-shu-xing-de-zuo-yong-yu</id>
        <link href="https://imenghu.github.io/post/python-zhong-de-lei-shu-xing-he-dui-xiang-shu-xing-de-zuo-yong-yu">
        </link>
        <updated>2019-11-19T04:58:47.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://imenghu.github.io/post-images/1574139587626.png" alt=""></figure>
<pre><code class="language-python">class Test:
    num=100 
    def __init__(self):
        self.age=18     

test1=Test()
test2=Test()
print(test1.num)    
test1.num=200  
&quot;&quot;&quot;
只是修改了这个对象作用域下的属性    
类中的num不会发生改变
&quot;&quot;&quot;
print(test1.num)   
print(Test.num)    
del test1.num       
print(test1.num)
</code></pre>
<p>def __init__方法的作用域限制在实例化出的对象<br>
self.age=18<br>
这里的age属性是对象的特有属性，类访问不到<br>
跟 p=person()<br>
p.age=18<br>
是一样的效果<br>
只有p能访问到这个age，person访问不到<br>
如果person中也有这个age，是在两个区域，互不影响<br>
除非在p中的age属性删除之后，p会向person中找相关的属性</p>
<pre><code class="language-python">class a:
    def __init__(self):
        self.name=&quot;a&quot;
        self.age=12
        self.score=23
    def test():
        print(&quot;类方法测试&quot;)
print(a.name)
&quot;&quot;&quot;
这里会报错，因为def __init__构造函数之内的属性只能通过
实例化对象之后，通过对象进行访问，类没有办法直接访问
如果是对象中再增加属性，或者修改属性的值，这些都跟类的属性没有关系
因为两种属性是在两个区域内创建的
&quot;&quot;&quot;
a.test()
</code></pre>
<p>对于类：</p>
<ol>
<li>
<p>类可以直接访问类属性</p>
</li>
<li>
<p>类不可以直接访问实例方法，必须通过实例化之后的对象来访问实例方法</p>
</li>
<li>
<p>类不可以访问对象特有的属性（比如：def __init__中定义的属性）</p>
</li>
<li>
<p>类可以直接访问类方法</p>
</li>
<li>
<p>类可以直接访问静态方法</p>
</li>
</ol>
<p>所以存在：如果对象中的属性跟类中的属性相同，改变对象中的属性值，不会影响类中的属性值</p>
<p>对于对象：</p>
<ol>
<li>
<p>对象可以直接访问类的属性（实例化过程中，类已经将属性赋给对象）</p>
</li>
<li>
<p>对象可以直接访问自己私有的属性</p>
</li>
<li>
<p>对象可以直接访问类方法</p>
</li>
<li>
<p>对象可以直接访问静态方法</p>
</li>
<li>
<p>对象可以直接访问实例方法</p>
</li>
</ol>
<pre><code class="language-python">class a:
    def __init__(self,name):
        self.name=name
        print(self.name)
    age=&quot;这是类属性&quot;
    def test(self):
        self.name=&quot;name已经修改&quot;
        self.age=&quot;age已经修改&quot;
        print(self.age)
        print(self.name)
a1=a(&quot;这是对象属性&quot;)
print(a.age)
print(a1.name)
print(a1.age)
a1.test()
</code></pre>
<p>这里所有的带有self的方法都是实例方法，只能由对象才能访问到，且实例方法中可以访问对象的属性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#调用python脚本]]></title>
        <id>https://imenghu.github.io/post/cdiao-yong-python-jiao-ben</id>
        <link href="https://imenghu.github.io/post/cdiao-yong-python-jiao-ben">
        </link>
        <updated>2019-11-14T05:22:27.000Z</updated>
        <content type="html"><![CDATA[<p>只尝试了两种调用方式，第一种只适用于python脚本中不包含第三方模块的情况，第二种针对的是python脚本中包含第三方模块的情况。不管哪种方式，首先都需要安装IronPython。可以在官网下载安装包自行安装后添加引用即可。<br>
C#代码</p>
<pre><code class="language-c#">using IronPython.Hosting;
using Microsoft.Scripting.Hosting;
using System;

namespace CSharpCallPython
{
    class Program
    {
        static void Main(string[] args)
        {
            ScriptEngine pyEngine = Python.CreateEngine();//创建Python解释器对象
            dynamic py = pyEngine.ExecuteFile(@&quot;test.py&quot;);//读取脚本文件
            int[] array = new int[9] { 9, 3, 5, 7, 2, 1, 3, 6, 8 };
            string reStr = py.main(array);//调用脚本文件中对应的函数
            Console.WriteLine(reStr);

            Console.ReadKey();
        }
    }
}
</code></pre>
<p>python代码</p>
<pre><code class="language-python">def main(arr):
    try:
        arr = set(arr)
        arr = sorted(arr)
        arr = arr[0:]
        return str(arr)
    except Exception as err:
        return str(err)
</code></pre>
<p><strong>注意</strong><br>
Q：找不到py文件<br>
A：检查最后执行文件路径，可能需要将文件属性中“复制到输出目录”设置为“始终复制”</p>
<p>Q：py文件方法执行异常<br>
A：检查py文件可否单独执行，如果可以执行，检查执行环境是否为3.x，可能需要py代码降级；如果不可执行，检查是否引用第三方包，第三方是否非全局安装</p>
<p>Tip：目前 IronPython 支持Python模拟运行环境为2.x</p>
<p>结果<br>
<img src="https://imenghu.github.io/post-images/1573709817355.png" alt=""></p>
<p>方式二：适用于python脚本中包含第三方模块的情况</p>
<p>C#代码</p>
<pre><code class="language-c#">using System;
using System.Collections;
using System.Diagnostics;

namespace Test
{
    class Program
    {
        static void Main(string[] args)
        {
            Process p = new Process();
            string path = &quot;reset_ipc.py&quot;;//待处理python文件的路径，本例中放在debug文件夹下
            string sArguments = path;
            ArrayList arrayList = new ArrayList();
            arrayList.Add(&quot;com4&quot;);
            arrayList.Add(57600);
            arrayList.Add(&quot;password&quot;);
            foreach (var param in arrayList)//添加参数
            {
                sArguments += &quot; &quot; + sigstr;
            }

            p.StartInfo.FileName = @&quot;D:\Python2\python.exe&quot;; //python2.7的安装路径
            p.StartInfo.Arguments = sArguments;//python命令的参数
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.RedirectStandardInput = true;
            p.StartInfo.RedirectStandardError = true;
            p.StartInfo.CreateNoWindow = true;
            p.Start();//启动进程

            Console.WriteLine(&quot;执行完毕！&quot;);

            Console.ReadKey();
        }
    }
}
</code></pre>
<p>python代码</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
import serial
import time

def resetIPC(com, baudrate, password, timeout=0.5):
    ser=serial.Serial(com, baudrate, timeout=timeout)
    flag=True
    try:
        ser.close()
        ser.open()
        ser.write(&quot;\n&quot;.encode(&quot;utf-8&quot;))
        time.sleep(1)
        ser.write(&quot;root\n&quot;.encode(&quot;utf-8&quot;))
        time.sleep(1)
        passwordStr=&quot;%s\n&quot; % password
        ser.write(passwordStr.encode(&quot;utf-8&quot;))
        time.sleep(1)
        ser.write(&quot;killall -9 xxx\n&quot;.encode(&quot;utf-8&quot;))
        time.sleep(1)
        ser.write(&quot;rm /etc/xxx/xxx_user.*\n&quot;.encode(&quot;utf-8&quot;))
        time.sleep(1)
        ser.write(&quot;reboot\n&quot;.encode(&quot;utf-8&quot;))
        time.sleep(1)
    except Exception:
        flag=False
    finally:
        ser.close()
    return flag

resetIPC(sys.argv[1], sys.argv[2], sys.argv[3])
</code></pre>
<p>上面的python脚本实现的是重启IPC设备，测试功能成功。</p>
<p><strong>调用包含第三方模块的python脚本时，尝试过使用path.append()方式，调试有各种问题，最终放弃了，没有研究。</strong></p>
<p><a href="https://github.com/imenghu/CSharpCallPython.git">git地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[getattr,setattr,hasattr详解]]></title>
        <id>https://imenghu.github.io/post/getattrsetattrhasattr-xiang-jie</id>
        <link href="https://imenghu.github.io/post/getattrsetattrhasattr-xiang-jie">
        </link>
        <updated>2019-11-13T01:25:12.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li><strong>hasattr(object, name)</strong></li>
</ol>
<p>判断一个对象里面是否有name属性或者name方法，返回BOOL值，有name特性返回True， 否则返回False。<br>
需要注意的是name要用括号括起来。</p>
<p>实例：<br>
<img src="https://img-blog.csdn.net/20181015192304290?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvdGVtYW4xMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<ol start="2">
<li><strong>getattr(object, name[,default])</strong></li>
</ol>
<p>获取对象object的属性或者方法，如果存在打印出来，如果不存在，打印出默认值，默认值可选。<br>
需要注意的是，如果是返回的对象的方法，返回的是方法的内存地址，如果需要运行这个方法，<br>
可以在后面添加一对括号。</p>
<p>实例：<br>
<img src="https://img-blog.csdn.net/20181015192352956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvdGVtYW4xMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<ol start="3">
<li><strong>setattr(object, name, values)</strong></li>
</ol>
<p>给对象的属性赋值，若属性不存在，先创建再赋值。<br>
<img src="https://img-blog.csdn.net/20181015192503188?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvdGVtYW4xMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python 中的两个函数dir,help]]></title>
        <id>https://imenghu.github.io/post/python-zhong-de-liang-ge-han-shu</id>
        <link href="https://imenghu.github.io/post/python-zhong-de-liang-ge-han-shu">
        </link>
        <updated>2019-11-12T01:57:04.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1. dir(对象名) 查看该对象的属性和方法。</strong><br>
<strong>2. help(对象名.属性名)  查看该对象属性(方法)的具体实现</strong><br>
<strong>3. print(C.<strong>mro</strong>) MRO 是 method resolution order，主要用于 在多继承时判断 方法、属性 的调用 路径</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git记忆图]]></title>
        <id>https://imenghu.github.io/post/git-ji-yi-tu</id>
        <link href="https://imenghu.github.io/post/git-ji-yi-tu">
        </link>
        <updated>2019-11-12T01:18:13.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://imenghu.github.io/post-images/1573521529589.png" alt=""></figure>
]]></content>
    </entry>
</feed>