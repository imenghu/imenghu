<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://imenghu.github.io</id>
    <title>i萌虎</title>
    <updated>2019-11-19T05:16:38.513Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://imenghu.github.io"/>
    <link rel="self" href="https://imenghu.github.io/atom.xml"/>
    <logo>https://imenghu.github.io/images/avatar.png</logo>
    <icon>https://imenghu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, i萌虎</rights>
    <entry>
        <title type="html"><![CDATA[python中的类属性和对象属性的作用域]]></title>
        <id>https://imenghu.github.io/post/python-zhong-de-lei-shu-xing-he-dui-xiang-shu-xing-de-zuo-yong-yu</id>
        <link href="https://imenghu.github.io/post/python-zhong-de-lei-shu-xing-he-dui-xiang-shu-xing-de-zuo-yong-yu">
        </link>
        <updated>2019-11-19T04:58:47.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://imenghu.github.io/post-images/1574139587626.png" alt=""></figure>
<pre><code class="language-python">class Test:
    num=100 
    def __init__(self):
        self.age=18     

test1=Test()
test2=Test()
print(test1.num)    
test1.num=200  
&quot;&quot;&quot;
只是修改了这个对象作用域下的属性    
类中的num不会发生改变
&quot;&quot;&quot;
print(test1.num)   
print(Test.num)    
del test1.num       
print(test1.num)
</code></pre>
<p>def __init__方法的作用域限制在实例化出的对象<br>
self.age=18<br>
这里的age属性是对象的特有属性，类访问不到<br>
跟 p=person()<br>
p.age=18<br>
是一样的效果<br>
只有p能访问到这个age，person访问不到<br>
如果person中也有这个age，是在两个区域，互不影响<br>
除非在p中的age属性删除之后，p会向person中找相关的属性</p>
<pre><code class="language-python">class a:
    def __init__(self):
        self.name=&quot;a&quot;
        self.age=12
        self.score=23
    def test():
        print(&quot;类方法测试&quot;)
print(a.name)
&quot;&quot;&quot;
这里会报错，因为def __init__构造函数之内的属性只能通过
实例化对象之后，通过对象进行访问，类没有办法直接访问
如果是对象中再增加属性，或者修改属性的值，这些都跟类的属性没有关系
因为两种属性是在两个区域内创建的
&quot;&quot;&quot;
a.test()
</code></pre>
<p>对于类：</p>
<ol>
<li>
<p>类可以直接访问类属性</p>
</li>
<li>
<p>类不可以直接访问实例方法，必须通过实例化之后的对象来访问实例方法</p>
</li>
<li>
<p>类不可以访问对象特有的属性（比如：def __init__中定义的属性）</p>
</li>
<li>
<p>类可以直接访问类方法</p>
</li>
<li>
<p>类可以直接访问静态方法</p>
</li>
</ol>
<p>所以存在：如果对象中的属性跟类中的属性相同，改变对象中的属性值，不会影响类中的属性值</p>
<p>对于对象：</p>
<ol>
<li>
<p>对象可以直接访问类的属性（实例化过程中，类已经将属性赋给对象）</p>
</li>
<li>
<p>对象可以直接访问自己私有的属性</p>
</li>
<li>
<p>对象可以直接访问类方法</p>
</li>
<li>
<p>对象可以直接访问静态方法</p>
</li>
<li>
<p>对象可以直接访问实例方法</p>
</li>
</ol>
<pre><code class="language-python">class a:
    def __init__(self,name):
        self.name=name
        print(self.name)
    age=&quot;这是类属性&quot;
    def test(self):
        self.name=&quot;name已经修改&quot;
        self.age=&quot;age已经修改&quot;
        print(self.age)
        print(self.name)
a1=a(&quot;这是对象属性&quot;)
print(a.age)
print(a1.name)
print(a1.age)
a1.test()
</code></pre>
<p>这里所有的带有self的方法都是实例方法，只能由对象才能访问到，且实例方法中可以访问对象的属性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#调用python脚本]]></title>
        <id>https://imenghu.github.io/post/cdiao-yong-python-jiao-ben</id>
        <link href="https://imenghu.github.io/post/cdiao-yong-python-jiao-ben">
        </link>
        <updated>2019-11-14T05:22:27.000Z</updated>
        <content type="html"><![CDATA[<p>只尝试了两种调用方式，第一种只适用于python脚本中不包含第三方模块的情况，第二种针对的是python脚本中包含第三方模块的情况。不管哪种方式，首先都需要安装IronPython。可以在官网下载安装包自行安装后添加引用即可。<br>
C#代码</p>
<pre><code class="language-c#">using IronPython.Hosting;
using Microsoft.Scripting.Hosting;
using System;

namespace CSharpCallPython
{
    class Program
    {
        static void Main(string[] args)
        {
            ScriptEngine pyEngine = Python.CreateEngine();//创建Python解释器对象
            dynamic py = pyEngine.ExecuteFile(@&quot;test.py&quot;);//读取脚本文件
            int[] array = new int[9] { 9, 3, 5, 7, 2, 1, 3, 6, 8 };
            string reStr = py.main(array);//调用脚本文件中对应的函数
            Console.WriteLine(reStr);

            Console.ReadKey();
        }
    }
}
</code></pre>
<p>python代码</p>
<pre><code class="language-python">def main(arr):
    try:
        arr = set(arr)
        arr = sorted(arr)
        arr = arr[0:]
        return str(arr)
    except Exception as err:
        return str(err)
</code></pre>
<p><strong>注意</strong><br>
Q：找不到py文件<br>
A：检查最后执行文件路径，可能需要将文件属性中“复制到输出目录”设置为“始终复制”</p>
<p>Q：py文件方法执行异常<br>
A：检查py文件可否单独执行，如果可以执行，检查执行环境是否为3.x，可能需要py代码降级；如果不可执行，检查是否引用第三方包，第三方是否非全局安装</p>
<p>Tip：目前 IronPython 支持Python模拟运行环境为2.x</p>
<p>结果<br>
<img src="https://imenghu.github.io/post-images/1573709817355.png" alt=""></p>
<p>方式二：适用于python脚本中包含第三方模块的情况</p>
<p>C#代码</p>
<pre><code class="language-c#">using System;
using System.Collections;
using System.Diagnostics;

namespace Test
{
    class Program
    {
        static void Main(string[] args)
        {
            Process p = new Process();
            string path = &quot;reset_ipc.py&quot;;//待处理python文件的路径，本例中放在debug文件夹下
            string sArguments = path;
            ArrayList arrayList = new ArrayList();
            arrayList.Add(&quot;com4&quot;);
            arrayList.Add(57600);
            arrayList.Add(&quot;password&quot;);
            foreach (var param in arrayList)//添加参数
            {
                sArguments += &quot; &quot; + sigstr;
            }

            p.StartInfo.FileName = @&quot;D:\Python2\python.exe&quot;; //python2.7的安装路径
            p.StartInfo.Arguments = sArguments;//python命令的参数
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.RedirectStandardInput = true;
            p.StartInfo.RedirectStandardError = true;
            p.StartInfo.CreateNoWindow = true;
            p.Start();//启动进程

            Console.WriteLine(&quot;执行完毕！&quot;);

            Console.ReadKey();
        }
    }
}
</code></pre>
<p>python代码</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
import serial
import time

def resetIPC(com, baudrate, password, timeout=0.5):
    ser=serial.Serial(com, baudrate, timeout=timeout)
    flag=True
    try:
        ser.close()
        ser.open()
        ser.write(&quot;\n&quot;.encode(&quot;utf-8&quot;))
        time.sleep(1)
        ser.write(&quot;root\n&quot;.encode(&quot;utf-8&quot;))
        time.sleep(1)
        passwordStr=&quot;%s\n&quot; % password
        ser.write(passwordStr.encode(&quot;utf-8&quot;))
        time.sleep(1)
        ser.write(&quot;killall -9 xxx\n&quot;.encode(&quot;utf-8&quot;))
        time.sleep(1)
        ser.write(&quot;rm /etc/xxx/xxx_user.*\n&quot;.encode(&quot;utf-8&quot;))
        time.sleep(1)
        ser.write(&quot;reboot\n&quot;.encode(&quot;utf-8&quot;))
        time.sleep(1)
    except Exception:
        flag=False
    finally:
        ser.close()
    return flag

resetIPC(sys.argv[1], sys.argv[2], sys.argv[3])
</code></pre>
<p>上面的python脚本实现的是重启IPC设备，测试功能成功。</p>
<p><strong>调用包含第三方模块的python脚本时，尝试过使用path.append()方式，调试有各种问题，最终放弃了，没有研究。</strong></p>
<p><a href="https://github.com/imenghu/CSharpCallPython.git">git地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[getattr,setattr,hasattr详解]]></title>
        <id>https://imenghu.github.io/post/getattrsetattrhasattr-xiang-jie</id>
        <link href="https://imenghu.github.io/post/getattrsetattrhasattr-xiang-jie">
        </link>
        <updated>2019-11-13T01:25:12.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li><strong>hasattr(object, name)</strong></li>
</ol>
<p>判断一个对象里面是否有name属性或者name方法，返回BOOL值，有name特性返回True， 否则返回False。<br>
需要注意的是name要用括号括起来。</p>
<p>实例：<br>
<img src="https://img-blog.csdn.net/20181015192304290?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvdGVtYW4xMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<ol start="2">
<li><strong>getattr(object, name[,default])</strong></li>
</ol>
<p>获取对象object的属性或者方法，如果存在打印出来，如果不存在，打印出默认值，默认值可选。<br>
需要注意的是，如果是返回的对象的方法，返回的是方法的内存地址，如果需要运行这个方法，<br>
可以在后面添加一对括号。</p>
<p>实例：<br>
<img src="https://img-blog.csdn.net/20181015192352956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvdGVtYW4xMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<ol start="3">
<li><strong>setattr(object, name, values)</strong></li>
</ol>
<p>给对象的属性赋值，若属性不存在，先创建再赋值。<br>
<img src="https://img-blog.csdn.net/20181015192503188?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvdGVtYW4xMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python 中的两个函数dir,help]]></title>
        <id>https://imenghu.github.io/post/python-zhong-de-liang-ge-han-shu</id>
        <link href="https://imenghu.github.io/post/python-zhong-de-liang-ge-han-shu">
        </link>
        <updated>2019-11-12T01:57:04.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1. dir(对象名) 查看该对象的属性和方法。</strong><br>
<strong>2. help(对象名.属性名)  查看该对象属性(方法)的具体实现</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git记忆图]]></title>
        <id>https://imenghu.github.io/post/git-ji-yi-tu</id>
        <link href="https://imenghu.github.io/post/git-ji-yi-tu">
        </link>
        <updated>2019-11-12T01:18:13.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://imenghu.github.io/post-images/1573521529589.png" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解读Python的命名空间]]></title>
        <id>https://imenghu.github.io/post/jie-du-python-de-ming-ming-kong-jian</id>
        <link href="https://imenghu.github.io/post/jie-du-python-de-ming-ming-kong-jian">
        </link>
        <updated>2019-11-08T02:29:14.000Z</updated>
        <content type="html"><![CDATA[<p>前面我们理解了变量、函数的作用域，现在我们再深入讨论一下Python是如何给变量、函数划分作用域的。</p>
<p>我们在编写Python程序的过程中，如果要使用变量和函数，都需要先对变量和函数命名后才能使用。Python会把命名后的变量和函数分配到不同的命名空间，并通过名称来识别它们。Python为什么要区分不同的命名空间呢？它有两个作用：一个作用是不同的命名空间对应不同的作用域；另外一个作用是防止命名冲突。</p>
<p>我们先来看第一个作用。前面我们已经知道了在函数内部声明的变量属于局部变量，在模块内部声明的变量属于全局变量。Python是如何确定哪个变量是属于全局还是局部呢？这就需要用到命名空间概念了。</p>
<p>Python会把在函数内部声明的变量放置到局部命名空间，把在模块声明的变量放置到全局命名空间。在局部命名空间的变量其作用域只能是在函数内部范围，在全局命名空间的变量其作用域为整个模块。函数的命名也同样适用于局部命名空间和全局命名空间，嵌套函数的命名是放置在局部命名空间的，因此其作用域只能在父函数范围；而父函数的命名是放置在全局命名空间的，因此其作用域适用于整个模块。</p>
<p>关于命名空间的作用域，这里面还有一个问题。那就是在模块或函数中使用的Python自身提供的内建函数，它是属于哪个命名空间呢？因为这些内建函数在模块中随意使用，没有作用域的限制。其实Python还为自己的函数、程序提供了一个命名空间，这个命名空间是内置命名空间，在内置命名空间放置的变量、函数，在整个Python程序模块中都可以被访问，其作用域是整个程序。</p>
<p>小结一下，在Python程序执行过程中，会有局部命名空间、全局命名空间和内建命名空间同时存在。局部命名空间记录函数内部的变量、传入函数的参数、嵌套函数等被命名的对象；全局命名空间记录模块的变量、函数、类及其它导入的模块等被命名的对象；内建命名空间记录Python自身提供的函数、模块等被命名的对象。</p>
<p>我们再来看命名空间的第二个作用。命名空间可以预防变量和函数的命名冲突。前面我们知道了Python有三类命名空间，分别是局部命名空间、全局命名空间和内建命名空间。Python在编译和解释执行Python代码的过程中，会为每个模块建立一个全局命名空间，为模块中的每个函数建立局部命名空间。相当于Python为程序的每个模块和函数提供了一个封闭的命名空间，在这个封闭的命名空间中，函数及变量命名互相不受影响，在不同的模块中可以声明相同名称的函数，在不同的函数中可以声明相同名称的变量，虽然它们的名称相同，但它们之间没有任何联系。</p>
<p>那么Python如何把已命名的变量及函数的作用域和命名空间联系起来了呢？它所要做的就是在命名空间查询变量或函数的名称。Python访问一个已命名的变量或函数时，它会从三个命名空间中查询。首先从局部命名空间开始，如果没有找到，它就会继续查找全局命名空间，如果在全局命名空间中也没找到，它将在内建命名空间里查找。如果这些查找都失败了，它将会报出下面的错误。</p>
<figure data-type="image" tabindex="1"><img src="https://imenghu.github.io/post-images/1573181566780.jpg" alt=""></figure>
<p>在Python解释器中，我们输入了foo，没有给foo进行赋值（声明变量时需要进行赋值）。解释器会从命名空间中查找foo，它先从局部空间查找，如果找到了它就会使用局部命名空间的变量foo，即使全局命名空间也有变量foo。这就很容易理解为什么在函数内部声明的局部变量会覆盖掉在模块中声明的同名变量。</p>
<p>Python提供了内建函数可以输出命名空间里面的内容。输出局部命名空间的内容使用locals()函数，输出全局命名空间的的内容使用globals()函数。</p>
<figure data-type="image" tabindex="2"><img src="https://imenghu.github.io/post-images/1573181560065.jpg" alt=""></figure>
<p>上面的代码给出了如何访问局部命名空间和全局命名空间的内容，命名空间的内容以字典形式给出，字典的key是已命名的变量或函数名称，value是这些变量或函数的值。从输出内容可以看出，局部变量的π覆盖了全局变量的π。下图是输出结果。</p>
<figure data-type="image" tabindex="3"><img src="https://imenghu.github.io/post-images/1573181574655.jpg" alt=""></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一篇文章让你彻底搞清楚Python中self的含义]]></title>
        <id>https://imenghu.github.io/post/yi-pian-wen-zhang-rang-ni-che-di-gao-qing-chu-python-zhong-self-de-han-yi</id>
        <link href="https://imenghu.github.io/post/yi-pian-wen-zhang-rang-ni-che-di-gao-qing-chu-python-zhong-self-de-han-yi">
        </link>
        <updated>2019-11-07T05:40:20.000Z</updated>
        <content type="html"><![CDATA[<p>刚开始学习Python的类写法的时候觉得很是麻烦，为什么定义时需要而调用时又不需要，为什么不能内部简化从而减少我们敲击键盘的次数？<br>
你看完这篇文章后就会明白所有的疑问。</p>
<p>self代表类的实例，而非类。<br>
实例来说明</p>
<pre><code class="language-python">class Test:
    def prt(self):
        print(self)
        print(self.__class__)

t = Test()
t.prt()
</code></pre>
<p>'''<br>
执行结果如下</p>
<p>&lt;<strong>main</strong>.Test object at 0x000000000284E080&gt;<br>
&lt;class '<strong>main</strong>.Test'&gt;<br>
'''<br>
从上面的例子中可以很明显的看出，self代表的是类的实例。而self.__class__则指向类。</p>
<p>self不必非写成self<br>
有很多童鞋是先学习别的语言然后学习Python的，所以总觉得self怪怪的，想写成this，可以吗？<br>
当然可以，还是把上面的代码改写一下。</p>
<pre><code class="language-python">class Test:
    def prt(this):
        print(this)
        print(this.__class__)

t = Test()
t.prt()
</code></pre>
<p>改成this后，运行结果完全一样。<br>
当然，最好还是尊重约定俗成的习惯，使用self。</p>
<p>self可以不写吗<br>
在Python的解释器内部，当我们调用t.prt()时，实际上Python解释成Test.prt(t)，也就是说把self替换成类的实例。<br>
有兴趣的童鞋可以把上面的t.prt()一行改写一下，运行后的实际结果完全相同。<br>
实际上已经部分说明了self在定义时不可以省略，如果非要试一下，那么请看下面：</p>
<pre><code class="language-python">class Test:
    def prt():
        print(self)

t = Test()
t.prt()
</code></pre>
<p>运行时提醒错误如下：prt在定义时没有参数，但是我们运行时强行传了一个参数。<br>
由于上面解释过了t.prt()等同于Test.prt(t)，所以程序提醒我们多传了一个参数t。</p>
<p>Traceback (most recent call last):<br>
File &quot;h.py&quot;, line 6, in <module><br>
t.prt()<br>
TypeError: prt() takes 0 positional arguments but 1 was given<br>
当然，如果我们的定义和调用时均不传类实例是可以的，这就是类方法。</p>
<pre><code class="language-python">class Test:
    def prt():
        print(__class__)
Test.prt()
</code></pre>
<p>运行结果如下</p>
<p>&lt;class '<strong>main</strong>.Test'&gt;<br>
在继承时，传入的是哪个实例，就是那个传入的实例，而不是指定义了self的类的实例。<br>
先看代码</p>
<pre><code class="language-python">class Parent:
    def pprt(self):
        print(self)

class Child(Parent):
    def cprt(self):
        print(self)
c = Child()
c.cprt()
c.pprt()
p = Parent()
p.pprt()
</code></pre>
<p>运行结果如下</p>
<p>&lt;<strong>main</strong>.Child object at 0x0000000002A47080&gt;<br>
&lt;<strong>main</strong>.Child object at 0x0000000002A47080&gt;<br>
&lt;<strong>main</strong>.Parent object at 0x0000000002A47240&gt;<br>
解释：<br>
运行c.cprt()时应该没有理解问题，指的是Child类的实例。<br>
但是在运行c.pprt()时，等同于Child.pprt(c)，所以self指的依然是Child类的实例，由于self中没有定义pprt()方法，所以沿着继承树往上找，发现在父类Parent中定义了pprt()方法，所以就会成功调用。</p>
<p>在描述符类中，self指的是描述符类的实例<br>
不太容易理解，先看实例：</p>
<pre><code class="language-python">class Desc:
    def __get__(self, ins, cls):
        print('self in Desc: %s ' % self )
        print(self, ins, cls)
class Test:
    x = Desc()
    def prt(self):
        print('self in Test: %s' % self)
t = Test()
t.prt()
t.x
</code></pre>
<p>运行结果如下：</p>
<p>self in Test: &lt;<strong>main</strong>.Test object at 0x0000000002A570B8&gt;<br>
self in Desc: &lt;<strong>main</strong>.Desc object at 0x000000000283E208&gt;<br>
&lt;<strong>main</strong>.Desc object at 0x000000000283E208&gt; &lt;<strong>main</strong>.Test object at 0x0000000002A570B8&gt; &lt;class '<strong>main</strong>.Test'&gt;<br>
大部分童鞋开始有疑问了，为什么在Desc类中定义的self不是应该是调用它的实例t吗？怎么变成了Desc类的实例了呢？<br>
注意：此处需要睁大眼睛看清楚了，这里调用的是t.x，也就是说是Test类的实例t的属性x，由于实例t中并没有定义属性x，所以找到了类属性x，而该属性是描述符属性，为Desc类的实例而已，所以此处并没有顶用Test的任何方法。<br>
那么我们如果直接通过类来调用属性x也可以得到相同的结果。<br>
下面是把t.x改为Test.x运行的结果。</p>
<p>self in Test: &lt;<strong>main</strong>.Test object at 0x00000000022570B8&gt;<br>
self in Desc: &lt;<strong>main</strong>.Desc object at 0x000000000223E208&gt;<br>
&lt;<strong>main</strong>.Desc object at 0x000000000223E208&gt; None &lt;class '<strong>main</strong>.Test'&gt;<br>
题外话：由于在很多时候描述符类中仍然需要知道调用该描述符的实例是谁，所以在描述符类中存在第二个参数ins，用来表示调用它的类实例，所以t.x时可以看到第三行中的运行结果中第二项为&lt;main.Test object at 0x0000000002A570B8&gt;。而采用Test.x进行调用时，由于没有实例，所以返回None。</p>
<p>总结<br>
self在定义时需要定义，但是在调用时会自动传入。<br>
self的名字并不是规定死的，但是最好还是按照约定是用self<br>
self总是指调用时的类的实例。<br>
以上所有代码在Python3.4中均测试通过。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[函数作用域的LEGB顺序]]></title>
        <id>https://imenghu.github.io/post/han-shu-zuo-yong-yu-de-legb-shun-xu</id>
        <link href="https://imenghu.github.io/post/han-shu-zuo-yong-yu-de-legb-shun-xu">
        </link>
        <updated>2019-11-07T05:19:14.000Z</updated>
        <content type="html"><![CDATA[<p>1.什么是LEGB？<br>
L:local 函数内部作用域<br>
E:enclosing 函数内部与内嵌函数之间<br>
G:global 全局作用域<br>
B:build-in 内置作用域</p>
<p>2.它们是作什么用的<br>
为什么非要介绍这个呢?或者说它们的作用是什么?<br>
原因是因为我们的在学习Python函数的时候，经常会遇到很多定义域的问题，全部变量，内部变量，内部嵌入的函数，等等，Python是如何查找的呢？以及Python又是按照什么顺序来查找的呢？这里做一个顺序的说明</p>
<p>3.顺序是什么<br>
跟名字一样，Python在函数里面的查找分为4种，称之为LEGB，也正是按照这种顺序来查找的。</p>
<p>首先，是local,先查找函数内部<br>
然后，是enclosing，再查找函数内部与嵌入函数之间（是指在函数内部再次定义一个函数）<br>
其次，是global，查找全局<br>
最后，是build-in，内置作用域</p>
<p>4.举例说明<br>
ex1</p>
<pre><code class="language-python">  passline = 60
  
  def func(val):
      if val &gt;= passline:
          print('pass')
      else:
          print('failed')
  
  func(89)    
</code></pre>
<p>''''''''''''<br>
pass<br>
[Finished in 0.2s]<br>
''''''''''''<br>
复制代码</p>
<p>Python函数首先查找local，在局部变量作用域里并没有passline的定义，然后发现函数内部并没有内嵌函数，这时Python开始查找global，在全局里查找到passline的定义，被调用。</p>
<p>ex2</p>
<pre><code class="language-python"> def Max(val1, val2):
     return max(val1, val2)
 
 print(Max(90, 100))
</code></pre>
<p>'''''''''<br>
100<br>
[Finished in 0.1s]<br>
'''''''''</p>
<p>Max函数里面直接调用另外一个函数，调用的max()（注意两个函数的大小写不一样）,该函数并没有被定义，但是却属于我们上述的第四种，属于build-in函数，既是在python标准库里的函数，内置的，可以直接调用的。最后一步才会查找到这里</p>
<p>关于第二种，属于内嵌函数，即使在函数里面再次定义一个函数，这时会首先查找local函数里面是否有定义，然后才会查找函数里面内嵌函数里面有没有定义，这一种有专门的名词，叫做闭包，闭包将在另外文章里专门写到</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 中类的作用域问题]]></title>
        <id>https://imenghu.github.io/post/python-zhong-lei-de-zuo-yong-yu-wen-ti</id>
        <link href="https://imenghu.github.io/post/python-zhong-lei-de-zuo-yong-yu-wen-ti">
        </link>
        <updated>2019-11-07T03:30:28.000Z</updated>
        <content type="html"><![CDATA[<p>今天写一段小代码的时候犯傻了，我试图在类中的方法内部直接访问类中的变量，大概是这样写的：</p>
<pre><code class="language-python">class Test:
    a = 1

    def __init__(self):
        print(a)

t = Test()

</code></pre>
<p>&quot;&quot;&quot;<br>
NameError: name 'a' is not defined<br>
&quot;&quot;&quot;<br>
很显然报了 NameError 错误，我错误地认为 <strong>init</strong> 方法里面是可以直接拿到类中定义的变量 a 的，实际上并不可以。<br>
如大家所知，Python 的作用域查找顺序是 LEGB，即局部作用域、外部作用域、全局作用域和内置作用域，这里面并不包含 C（类作用域）。<br>
下面引用来自《Python 学习手册》第 859 页的一段话来说明这一点：</p>
<p>** 尽管类能够访问外层函数的作用域，但它们不能作为类中其它代码的外层作用域：Python 搜索外层函数来访问被引用的名称，但从来不会搜索外层类。也就是说，类是一个可以访问其外层作用域的局部作用域，但其本身却不能作为一个外层作用域被访问。因为方法函数中对名称的搜索跳过了外层的类，所以类属性必须作为对象属性并使用继承来访问。**</p>
<p>所以在上面如果要访问到 a 的话，只能通过点号取属性访问，比如 self.<strong>class</strong>.a。</p>
<p>** 二、属性的获取机制 **<br>
python 中的属性获取存在一个向上查找的机制。<br>
<img src="https://imenghu.github.io/post-images/1573692965568.png" alt=""></p>
<ul>
<li>因此要访问类属性的方式有两种：
<ol>
<li>类名. 类属性</li>
<li>对象.类属性(不推荐)</li>
</ol>
</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>如果使用 <em><strong>对象.类属性 = 值 赋值语句</strong></em>,   <strong>只会给对象添加一个属性</strong>，而不会影响到类属性的值</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[sql语句之case when null 解决方法]]></title>
        <id>https://imenghu.github.io/post/sql-yu-ju-zhi-case-when-null-jie-jue-fang-fa</id>
        <link href="https://imenghu.github.io/post/sql-yu-ju-zhi-case-when-null-jie-jue-fang-fa">
        </link>
        <updated>2019-11-06T10:51:34.000Z</updated>
        <content type="html"><![CDATA[<p>//判断空值,成功!!</p>
<pre><code class="language-sql">   select case  
          when 项目名称  IS NULL  
          then '空值'  
          when 项目名称 ='北二环'  
          then 'A'  
          when 项目名称 ='北三环'  
          then 'B'  
          else 'C'  
          END  项目名称  
   from   物件设计数量统计表

</code></pre>
]]></content>
    </entry>
</feed>