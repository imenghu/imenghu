<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://imenghu.github.io</id>
    <title>i萌虎</title>
    <updated>2019-11-22T07:12:08.121Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://imenghu.github.io"/>
    <link rel="self" href="https://imenghu.github.io/atom.xml"/>
    <logo>https://imenghu.github.io/images/avatar.png</logo>
    <icon>https://imenghu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, i萌虎</rights>
    <entry>
        <title type="html"><![CDATA[【Python&数据结构】 抽象数据类型 Python类机制和异常]]></title>
        <id>https://imenghu.github.io/post/pythonandshu-ju-jie-gou-chou-xiang-shu-ju-lei-xing-python-lei-ji-zhi-he-yi-chang</id>
        <link href="https://imenghu.github.io/post/pythonandshu-ju-jie-gou-chou-xiang-shu-ju-lei-xing-python-lei-ji-zhi-he-yi-chang">
        </link>
        <updated>2019-11-22T07:01:44.000Z</updated>
        <content type="html"><![CDATA[<p>抽象数据类型</p>
<p>最开始的计算机语言，关注的都是如何更加有效率地计算，可以说其目的是计算层面的抽象。然而随着这个行业的不断发展，计算机不仅仅用于计算，开发也不仅只关注计算过程了，数据层面的抽象也变得同样重要。虽然计算机语言一开始就有对数据的抽象，但是那些都只是对一些最基本的数据类型而不包括我们想要用的，多种多样的数据。</p>
<p>数据类型：<br>
　　　　程序处理的数据，通常是不同的类型的。只有事先约定好的不同类型的数据的存储方式，计算机才能正确理解逻辑上不同的数据类型。所有编程语言都会有一组内置的基本数据类型。另外在实际工作过程中，或早或晚总会碰到一些没法用现有数据类型解决的问题，这时就需要自定义一些数据类型来解决。像Python这样比较高级的语言的话，在基本类型的基础上还添加了一些额外的数据结构如tuple,list,dict（这些广义上来说也算是Python的数据类型）。</p>
<p>■　　抽象数据类型</p>
<p>以上基本数据类型都是比较simple，naive的结构，而且有一点很违和的是，以上数据结构都把数据暴露在外。如果一个人有了对某个变量的权限的话他就可以看到这个变量代表的数据结构中的所有数据。为了解决这个问题，必须要有一种数据类型，它可以让使用者只需要考虑如何使用这种类型的对象，而不需要（或者根本不能）去关注对象内部的实现方式以及数据的表示等等。这样的对象和类型从概念上来说就是抽象数据对象和抽象数据类型了。</p>
<p>抽象数据类型的基本想法是把数据定义为抽象的数据对象集合，只为他们定义可用的合法操作而不暴露内部实现的具体细节，不论是操作细节还是数据的存储细节。在这样的思想指导下，一般而言的抽象数据类型应该具有下列三种操作：</p>
<p>1. 构造操作（比如python类中的__init__方法）</p>
<p>2. 解析操作（getxx方法）</p>
<p>3. 变动操作（setxx方法）</p>
<p>看到这三种操作之后，根据这三个性质可以区分出数据类型的变动性。如果一个类型只有1和2两种操作那么就是不可变的类型，如果一个类型具备三种操作，那么就是一个可变的类型。在Python中，对象分成可变和不可变的，从抽象数据类型的角度来看就是看这个类型有没有变动操作的一个判断。</p>
<p>■　　Python的类</p>
<p>Python中的类就是一种抽象数据类型的实现，定义好的一个类就像是一个系统内部类型，可以产生该类型的对象（或者也可以叫它实例），实例具有这个类所描述的行为。实际上，Python的内置类型也都可以看做是类的一种从而进行一些类似“类”的操作。</p>
<p>关于类如何定义，一些基本的方法看下基本教程就懂了。之前有接触过一点java，总体来说，python的类的定义方法和java是类似的，而且比java要简单一点（比如python中定义类和类中的方法时不必指出类的公用性有多大，比如是public,private还是其他什么标志）</p>
<p>下面讲些稍微高端一点的类定义的规范和方法</p>
<p>●  关于内部使用的属性和方法<br>
　　在java里面，在类内部使用的方法和属性通常要加上修饰符private使得外部的调用者没办法直接访问这些方法和属性。Python中也有类似的机制，分成两种形式。一是把这种只提供给内部使用的属性（方法）的名字前面加上一个下划线以提示其私有的性质，这样的写法并不是语言规定而是人们约定俗成的，也就是说如果你想要通过实例直接访问一个下划线开头的属性或者属性方法也是可行的只不过不鼓励这么做。第二种形式是以两个下划线开头作为属性（方法）的名字，当然它不能同时以两个下划线结尾，这样就变成了魔法方法了。这种两个下划线的形式的属性是和java中的private一样的，如果从类的外部去访问这个属性的话会抛出AttributeError提示找不到相关属性。</p>
<p>●  关于类属独立属性（类变量）<br>
　　有时候，可以在类中的所有属性方法外面添加一些属性。这些严格来说都已经不算是类的属性了，因为他们和类的实例是完全不搭界的，有点像Java中的static类变量。对于这类“属性”几点想说：</p>
<p>1. 因为这些属性常常写在类的最上面，有时候可能会受到java的影响而下意识的以为这些属性是跟实例关联的，实则不然。就像函数参数的默认值一样，在函数被定义好的时候就被初始化好并保存在内存中的特定地址里不会随着调用函数次数的变化而变化一样，类属独立属性是在类被定义好的时候就被保存了起来，不会因为类被实例化了多少次而被初始化多少次，而且不论通过类名还是实例去调用它它的值都是一样的（也就是说python中的“类变量”是自带static属性的）。所以在比如类需要统计一共被实例化了多少次的场景中，可以在类中的所有方法外写一个count = 0然后在类的__init__方法中添加一句count+=1。这样每次实例化调用__init__的时候会让count加上1而不是初始化回0的状态。</p>
<p>2. 这种属性也不能理解成类的局部变量。在这个类的方法中我们不能直呼其名地调用这些属性，而是得像在类外面一样通过圆点的形式来调用相关属性。比如：</p>
<pre><code class="language-python">class Counter():
  count = 0
  def __init__(self):
    count += 1    #这会报错
    Counter.count += 1    #必须这么写
</code></pre>
<p>当然如果是类方法的话可以在方法中用cls.attribute的形式调用相关属性。下面也会有提到。</p>
<p>注意：在类的属性方法中是可以通过self.attribute的形式来调用类属独立属性的，在类定义外面也可以通过o.attribute来调用类属独立属性，但是要明确一点，类在实例化时，将类独立属性的名字告诉实例并把地址赋给它。但是之后实例所得到的类独立属性已经和原来的类独立属性有了区别，如果属性值是可变对象，那么实例对它自身的类独立属性修改会反映到类调用类独立属性时的值，如果是不可变对象，那么实例对它自身的类独立属性修改是不影响类调用类独立属性时的值的，比如（写得有些凌乱。。可以参考下面写的【对python类实例化时操作的一些思考】）：</p>
<pre><code class="language-python">class Test(object):
    num = 1
    lst = [1]
    lst2 = [1]

t = Test()
t.num = 2
t.lst.append(2)
t.lst2 = [2]
print Test.num,Test.lst,Test.lst2

#得到结果是1 [1, 2] [1]
</code></pre>
<p>另外成功调用还要建立在一个基础上，即这么调用的那个实例本身没有和类属独立属性重名的属性存在。比如：</p>
<pre><code class="language-python">class Test(object):
    count = 1
    def __init__(self):
        self.count = 2

    def get_count(self):
        print self.count
t = Test()
t.get_count()
del(t.count)　　#可以通过del函数解除一个属性和实例的关系，即删除属性的操作。
t.get_count()
#结果
#2
#1
#第一次调用get方法的时候，t先找自身哟没有名为count的属性，找到就返回了。但是第二回的时候，在自身没有找到而在类中找到了一个独立属性名为count，而它也是可以调用的，所以就返回了那个count
</code></pre>
<p>如果无论如何都有同名的变量的话，那么可以通过t.<strong>class</strong>.count来指定访问属于类的类变量。另外就上面给出的那个Counter.count+=1的例子而言，这里如果换成了self.count += 1的话可能达不到目的。原因在之前的某篇文章中也提到过，即python中的赋值语句还兼顾了声明变量的功能。这里的self.count = self.count + 1，右边的self.count确实引用了类属独立属性的count，然而左边的self.count被解释成为实例自身添加一个count的属性。因此如果写成self.count +=1的话，作为类属独立属性的count始终是0而每个被初始化出来的Counter的实例里面会有一个count的属性覆盖了类属独立属性，其值是1。</p>
<p>3. self.attribute是不能写在外面的！总是把self误认为是类对象，其实应该是调用时的实例对象。换句话说，在所有方法外面写self.attribute的话，self是什么东西解释器是不知道的。唯有在写方法中（which的第一个参数是self），在调用方法的时候解释器可以把调用方法的实例作为参数约束给self，这样self才会有意义。</p>
<p>●  关于静态方法<br>
　　在java中，可以用提示符static来表明某个方法是独立于其他同一个类中其他方法的静态方法。所谓静态方法就是说要调用这个方法可以不必通过类的实例而直接通过类名来调用。在Python中，类本身也是一个对象，通过类名本身来调用一个方法看起来似乎合情合理，为了满足这种需求，Python的类中可以通过添加修饰符@staticmethod来使得一个方法变成类的静态方法。静态方法的参数中没有self并且也可以通过类的实例来调用。从某种意义上说，静态方法其实算是类里面定义的普通函数，是一个类的局部函数。</p>
<p>●  关于类方法<br>
　　和静态方法类似的，类方法用@classmethod修饰符来表示。类方法和普通的属性方法一样，一般自带一个参数叫cls，在方法中代表调用这个类方法的类对象（通常是正在定义的这个类或者其父类或子类），然后在方法体中就可以用cls</p>
<p>来refer to这个类本身啦。比如书上有这样一个例子</p>
<pre><code class="language-python">class Counter(object):
    count = 0
    def __init__(self):
        Counter.count += 1

    @classmethod
    def get_count(cls):
        return cls.count

x = Counter()
print x.get_count()
y = Counter()
print y.get_count()

######结果是
1
2
</code></pre>
<p>这个例子说明了两个问题。一，对于类方法而言，其参数cls在调用时确实约束到了调用它的那个类对象上。二，对于属于类本身的独立属性，其并不根据实例的初始化而初始化。</p>
<p>●  类中的魔法方法<br>
　　关于魔法方法的说明可以参考魔法方法那篇笔记，这里不多提。想说的是一个小技巧，比如在一个类中要定义一个比大小的魔法方法，而比较的类的一个属性的时候，下意识的总会写</p>
<pre><code class="language-python">def __lt__(self,another):
  if self._attribute &lt; another._attribute:
    return True
  else:
    return False
　　但是实际上可以这么写更简洁，而且因为拿来作比较外部实例的不一定也有_attribute这个属性，最好还能加上一个异常排除的过程：

def __lt__(self,another):
  try:
    return self._attribute &lt; another._attribute
  except AttributeError as e:
    raise e
</code></pre>
<p>●  关于__init__和构造方法<br>
　　如果一个类中定义了__init__方法，那么在创建这个类的实例时解释器后自动调用这个方法初始化这个对象。之前一直认为python类中的__init__方法就是java中的构造方法。其实这两者还是有些微妙的区别的。比如java的一个类中不能没有构造方法（好像是这样吧= =），但是python的一个类中可以没有__init__方法，没有__init__方法时所有基于这个类创建实例的动作都会创建出一个空实例，此时解释器实际上调用的是object()方法，而object是Python中所有类的父类。</p>
<p>*关于python类实例化时操作的一点探索：python类在实例化的时候，会把类的所有成员对象（包括类独立属性和类方法）复制一个副本给实例，而这些成员对象的引用都指向类定义中成员对象的值。由于是副本，所以我们可以对实例的成员对象做出引用迁移，即用等号赋值以改变其引用，这样的话实例做出的属性改变就和类无关。如果我们通过实例改变一些可变的成员对象的值，那么会引起类中成员对象的变化。这就导致了下次实例化时，本次的变化会体现在下个实例中。请看下面的例子：</p>
<pre><code class="language-python">class Test(object):
  num = 1
  lst = [1]
  def __init__(self):
    pass
  def method_in_class(self):
    print &quot;in_class_method is called&quot;

def method_out_class():
  print &quot;out_class_method is called&quot;

t = Test()
t.num = 2
t.lst.append(2)
t.method_in_class = method_out_class
t.method_in_class()    #打印结果 out_class_method is called
k = Test()
print k.num,k.lst    #打印结果  1 [1,2],可以看到因为lst是可变对象，t对lst做出的改变反映在了k里
k.method_in_class()     #打印结果 in_class_method is called。函数也是对象，不过t做出的改变是赋值，相当于改变了t.method_in_class方法的引用，不影响类定义中的method_in_class。所以k是不受影响
</code></pre>
<p>●  关于一般成员方法的属性化<br>
　　在java中，常常会在类中声明一个private变量var，然后再类中设计getVar()和setVar(value)方法来通过方法的包装实现对var的改变。当在python中进行面向对象编程时，也偶尔会用到这种模式，比如：</p>
<pre><code class="language-python">class Test():
  def __init__(self):
    self.var = None
  def getVar(self):
    return self.var
  def setVar(self,value):
    self.var = value
</code></pre>
<p>但是这样做有一个问题，在类的实例被初始化之后，我们可以直接通过实例名.var的方式对var做出改变，这使得setVar和getVar两个方法显得没有意义而且不安全。java中有private这种关键字可以解决这个问题，有人会说python中可以把var改成_var可以提示这是个私有变量。不过_var只是一个提示性而不是强制性的，更重要的是用setVar和getVar方法来做这件事略显麻烦，不符合python一切从简的原则。基于这样一种思想，python提供了@property这种装饰器，其作用是自动把类似于setVar,getVar这种样子的变量变更机制转换成更加简洁的调用形式同时不绕开setVar和getVar的代码。一个典型的例子：</p>
<pre><code class="language-python">class Test(object):
    def __init__(self):
        self._var = None

    @property
    def var(self):
        raise Exception(&quot;var is not a readable attribute&quot;)

    @var.setter
    def var(self,value):
        if isinstance(value,str):
            self._var = value

t,k = Test(),Test()
t.var,k.var = 123,&quot;abc&quot;
print t.var,k.var
#结果是None abc
</code></pre>
<p>从根本上看，@property装饰的函数可以被看成是一个类的属性，通过 “实例.函数名”的方式就可以调用其返回的值。另一方面，引申出了@函数名.setter这个装饰器，其装饰的函数可以看做是setVar方法，只不过可以直接通过赋值语句调用。在这个例子中可以看到，@var.setter装饰的函数检查要设置的值是否为字符串类型，只有字符串类型才设置上去，所以t.var = 123并不成功，但k.var = &quot;abc&quot;成功了。如此可以让调用属性变得简洁，同时实际上我们是隐形地调用了类似于setVar,getVar的方法，可以在方法中加上一些控制条件以完善安全性或其他性能。</p>
<p>另外需要注意的是@property下的函数名、@xxx.setter中的xxx以及被它修饰的函数的函数名最好都能一致，以体现他们都是为同一个类的成员属性服务的。</p>
<p>■　　类的使用和对象（实例）</p>
<p>某个程序基于类C创建了实例o然后用o以调用属性方法的形式调用了方法m，前半个过程中python解释器的工作原理可能是跟我上面说的【关于python类实例化时操作的一点探索】有关，而这后半个过程中，python解释器是这样工作的。创建一个空方法对象，约束对象o和方法m到这个方法对象上去。正如大家所知，类中的属性方法在定义的时候通常第一个参数是self，这是因为需要把一个实例作为一个参数传递到方法中去这就是为什么方法对象约束的不仅仅是m还有o的原因。当o被作为第一个参数传递给m之后，m里面的self指的就是o这个实例了。</p>
<p>对于静态方法，在定义的时候就没有要写self，所以自然就没必要约束调用它的实例，这也是为什么它可以用类名直接调用的原因了。</p>
<p>其实从上面的说明中已经不难看出，一般属性方法调用时的o.m()其实等价于C.m(o)</p>
<p>●  关于增删属性和属性的赋值语句<br>
　　python的类的实例属性都维护在实例的__dict__这个隐藏属性中。因为它本身就是一个字典，所有我们可以动态地对某个实例的属性做出增删操作。操作具体不用通过__dict__这个变量，而是直接通过o.new_attribute = &quot;new_value&quot;的形式。当o已经存在new_attribute这个名称的属性的时候，这个属性的内容会被新的赋值语句覆盖掉。而删除操作可以通过del(o.attribute)来实现。</p>
<p>至于在类定义的内部，可以在任何一个方法中通过self.new_attribute = xxx来实现为类添加一个新属性。这就出现了一个很有意思的现象，所有类似于self.new_attribute=xxx都会被看做是为类添加新属性或者改变现有属性值的行为。</p>
<p>●  在一个属性方法中调用另一个属性方法<br>
　　同一个类中如果出现这种情况，就可以通过self.another_method()的形式来调用实现，而不是直接another_method()。另外，如果调用这个语句的不是本类的实例而是一个子类的实例，然后这个子类还没有重写这个语句所在的方法但是却重写了another_method这个方法的话，这就导致了一个问题（我靠我都晕了，实例看下）：我应该执行哪个类中的another_method，是父类还是子类的。</p>
<pre><code class="language-python">class Parent():
  def f(self):
    self.g()
  def g(self):
    print &quot;this is method g in Parent&quot;

class Child(Parent):
  def g(self):
    print &quot;this is method g in Child&quot;


c = Child()
c.f()

##结果是
#this is method g in Child
</code></pre>
<p>这种现象说好听一点叫动态约束，因为c在调用方法f的时候传递给f的参数self的是c实例本身，而通过self调用的g自然是通过实例c调用的g，也就是类Child中定义的g方法了。</p>
<p></p>
<p>■　　类的继承</p>
<p>上面这个例子其实已经提到了类的继承了。python中类的继承机制和java也都差不多，不同的是python中支持多类继承一类也支持一类继承多类，后者在java中好像是不行的吧（记不太清了。。）。还是讲一下在实际运用过程中可能会碰到的一些问题</p>
<p>●  issubclass和isinstance<br>
　　isinstance函数用来检查某个对象是不是某个类的实例，issubclass用来检查一个类是不是另一个类的子类。对于多层继承，比如class A(),class B(A), class C(B)的情况，issubclass(C,A)返回True。同时子类的实例也被默认为也是父类的实例，所以isinstance(C(),A)和isinstance(C(),B)也都是返回True的。</p>
<p>●  在子类中调用父类的初始化方法 super函数<br>
　　在java中，似乎是用super()指代父类的构造方法的。python中也有super方法不过用法不太一样：在python中如果想要在子类中调用父类的初始化构造方法有两种写法，分别是</p>
<p>Parent.<strong>init</strong>(self,...)和super().<strong>init</strong>(...)。前一种很好理解，相当于是通过父类对象来调用其初始化方法，把子类初始化时的那个实例作为父类初始化方法的参数来执行。至于第二个，在python中的super函数其实是返回一个父类的实例，通过实例来调用自然就不用self参数了。就调用父类的初始化方法而言，还是建议用前面一种，因为毕竟用一个创建后立刻销毁的对象作为父类初始化方法的self参数总感觉有点不太对劲。而对于父类中的其他方法，如果想要调用那么可以super().method(...)这样是很自然的。（这部分存疑。。书上是这么说的但是实验一下通不过，报错说在python2中super()必须要有一个参数，而书上用的是python3）当然也可以通过Parent.method(self,...)的形式来调用。已经证实，super()只是Python3中的写法。</p>
<p>super函数还有另外一种写法，就是super(Class,object).method(...)，这个语句可以出现在程序的任何地方而不一定要是在类的属性方法定义中。这个语句的意思是从Class类的父类开始逐级向上搜索前辈类，在类中找到属性方法method之后把object这个Class的实例作为method的self参数传递过去，然后执行method。比如上面那个动态约束的例子，在Child类中重写一下f方法：</p>
<pre><code class="language-python"> def f(self):
   super(Child,self).g()

#这样运行的结果就变成了
#this is method g in Parent
　　在这个f方法中，通过super函数强行把g方法关联到父类中的g方法而不是动态约束到子类中的g方法。
</code></pre>
<p>●  关于super的具体机理<br>
　　上面关于super函数的工作原理非常不细致。。“从Class类的父类开始逐级向上搜索前辈类”这句话不严谨。很明显的一个漏洞是，Python中存在着多重继承的情况，如果一个类继承了多个类那么Class类的父类该选择哪个呢？也就是说，super函数返回了一个父类实例，究竟是不是父类的实例，又是哪个父类，是怎么决定的。</p>
<p>首先要了解，Python中的类有一个魔法属性叫做__mro__，MRO的全称是Method Resolution Order即方法解析顺序。其值是一个元组，元组嘛自然是有0-n的顺序的。这个元组的内容就是以本类为0号位，object这个最高的基类作为最后一位，中间是按照一定算法排列的本类的所有先辈类，这样一个元组。比如一个class A(object)的__mro__就是(&lt;class '<strong>main</strong>.A'&gt;, &lt;type 'object'&gt;)，而如果再来个class B(A)，那么就是(&lt;class '<strong>main</strong>.B'&gt;, &lt;class '<strong>main</strong>.A'&gt;, &lt;type 'object'&gt;)。</p>
<p>知道了__mro__之后，其实super(cls,inst)函数的本意是在inst对象的__mro__元组中，寻找cls类的后一个类，返回的是这个类，然后如果后面还跟了调用方法的操作，那么此时通过这个类以及super中inst参数的值作为一个实例来调用的。对于刚提到的B，super(B,self)，由于self就是自身类的实例，__mro__如上面提到的那样，而cls参数值是B，即&lt;class '<strong>main</strong>'.B&gt;，寻找它的下一个类即A类，所以super最终返回了A类。</p>
<p>虽然看起来大多数情况下super就是返回了父类的实例，但是实际上super函数和父类没啥关系，它寻找下一个类的依据是__mro__属性这个元组，并且返回的不是这个类的实例而是这个类本身!</p>
<p>比如下面这段代码很好地说明了这点：</p>
<pre><code class="language-python">class A(object):
  def go(self):
    print 'AAA GO'

class B(A):
  def go(self):
    super(B,self).go()
    print 'BBB GO'

class C(A):
  def go(self):
    super(C,self).go()
    print 'CCC GO'

class D(B,C):
  def go(self):
    super(D,self).go()
    print 'DDD GO'

print D.__mro__
d = D()
d.go()

'''
结果是
(&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;type 'object'&gt;)
AAA GO
CCC GO
BBB GO
DDD GO
'''
</code></pre>
<p>首先看到了D的__mro__顺序是D、B、C、A，这个顺序是Python内部通过一种叫做C3算法的广度优先算法计算出来的。</p>
<p>实例化D后调用D的go方法，进入方法之后，第一次调用了super，此时inst参数是self即D类实例，cls参数是D类，所以super返回的B类。变成了B类调用go方法，然后go中要求的self参数用的就是第一次调用super时的那个inst参数即一个d类实例，好，进入B类的go方法。现在第二次调用super，此时inst参数的值是self，但是注意！self还是刚才的d类实例！于是神奇的一幕发生了，__mro__还是刚才那个mro，但是第一个参数由D变成了B，B的下一个类是C而不是A。因此，继续调用go方法时，调用的主体不是A类而是C类！进入C类的go方法之后同理，mro还是同一个，找到下一个是A类。A类没啥说的，直接print，完了返回之后回到C类go方法。所以stdout中第二行输出是C，第三行输出是B，而不是我们所想当然的反过来的情况。</p>
<p>python异常</p>
<p>Python中的所有异常都是作为一种类而存在的，Python系统给出了很多系统自带的常用的异常。一般如果用户需要自定义异常的话可以选择某一个异常作为父类来衍生出一个自定义异常。所有异常的总父类是Exception类。</p>
<p>所有的异常类在初始化的时候都可以接受一个字符串作为错误信息,比如在自定义一个异常类的时候可以：</p>
<pre><code class="language-python">class MyException(Exception):
  def __init__(self):
    Exception.__init__(self,&quot;My Exception is Raised&quot;)

raise MyException

#结果
# Traceback (most recent call last):
#   File &quot;D:/PycharmProjects/TestProject/test.py&quot;, line 8, in &lt;module&gt;
#     raise MyException
# __main__.MyException: My Excpetion is Raised
</code></pre>
<p>如果对错误判断没有太多要求的话可以方便地raise Exception(&quot;some error message&quot;)来抛出一个有提示文字的错误。但是在更多情况下，我们可能会根据具体的业务要求来对代码运行做一些逻辑判断，比如某些情况下可以抛出我们的自定义异常，然后在调用这些代码的时候except我们的自定义异常，这样就可以做到符合业务逻辑的异常捕获和处理了。</p>
<p>●  异常的传播和捕获<br>
　　如果异常发生在一个try语句块里面，那么解释器将按照顺序先检查这个try语句块相应的except语句块有没有为这个异常准备好处理器，如果没有的话那么就把这个异常交给更外层的try语句（如果有的话），这样逐层传播异常，如一直传播到这个异常所在的函数的最外层也没能找到相关的处理器的话那么这个函数就将异常中止运行，程序也因此整个中止。</p>
<p>如果在搜索过程中找到了相关的异常处理器的话，那么把执行点从异常语句的地方跳到处理器头部（也就是说跳过了try语句块中从异常位置到最后部分的所有代码）。在处理器的代码中还可能遇到新的异常，也可以在处理器代码中抛出异常。</p>
<p>●  实例<br>
　　书中提到了实现一个大学人事管理系统框架的实例，当然是一个很简朴的东西，逻辑也不复杂，不过其中有些面向对象编程的常识性的知识和技巧值得一看。我决定照样子把这段代码全部都抄过来，在有价值的 地方注释一下。</p>
<p>其基本思路是这样的：</p>
<p>实现一个公共人员的类，包含一些人的基本信息属性</p>
<p>创建学生和教职人员两个类，分别继承公共人员类。再根据学生和教职人员的属性不同来实现不同的类。</p>
<p>首先是两个本例中可能会用到的异常类型：</p>
<pre><code class="language-python">class PersonTypeError(TypeError):
    pass

class PersonValueError(ValueError):
    pass
 
</code></pre>
<p>然后是公共人员类：</p>
<pre><code class="language-python">class Person(object):  #实现一个公共的人员类
    _num = 0    #用来记录创建过的总人数
    def __init__(self,name,sex,birthday,ident):
        if not (isinstance(name,str)) and sex in (&quot;女&quot;,&quot;男&quot;):
            raise PersonValueError
        try:
            birth = datetime.date(*birthday)
        except:
            raise PersonTypeError(&quot;Wrong Date:{0}&quot;.format(birthday))
        self._name = name
        self._sex = sex
        self._id = ident
        self._birthday = birth
        Person._num += 1

    def id(self): return self._id
    def name(self): return self._name
    def sex(self): return self._sex
    def birthday(self): return self._birthday
    def age(self):
        return datetime.date.today() - self._birthday.year
    def set_name(self,new_name):
        if not isinstance(new_name,str):
            raise PersonValueError(&quot;Wrong New Name:{0}&quot;.format(new_name))
        self._name = new_name
    #其他的set方法不一一列举了，反正都是差不多的

    def __lt__(self,other):
        #定义一个比较魔法方法，当两个人员对象比较时默认比较他们的id号的大小
        if not isinstance(other,Person):
            raise PersonTypeError(other)
        return self._id &lt; other._id

    @classmethod
    def num(cls):   #定义一个获取目前为止总的注册人数的方法
        return cls._num

    def __str__(self):  #定义当print此类对象时的操作
        return &quot; &quot;.join((self._id,self._name,self._sex,self._birthday))
</code></pre>
<p>然后是学生类，学生类中需要有学号这个id，但是学号应该有一套生成的规则，这个规则应该放在Student这个类中维护，所以这个类中应该额外加一个学号生成的方法：</p>
<pre><code class="language-python">class Student(Person):
    &quot;&quot;&quot;学生类主要考虑增加院系，入学年份以及课程情况的三种信息
    &quot;&quot;&quot;
    _id_num = 0

    @classmethod
    def _id_gen(cls):
        cls._id_num += 1
        year = datetime.date.today().year
        return &quot;1{:04}{:05}&quot;.format(year, cls._id_num)  # 生成一个类似于 1201300001的学号，1代表学生，2013是入学年份，00001是学生编号

    def __init__(self, name, sex, birthday, depart):
        Person.__init__(self, name, sex, birthday, self._id_gen())
        self._department = depart
        self._enroll_year = datetime.date.today().year
        self._courses = {}

    def set_course(self, course):  # 模拟选课，选课刚开始还没有成绩
        self._courses[course] = None

    def set_score(self, course, score): #模拟给分
        if course not in self._courses:
            raise PersonValueError(&quot;The Course is not Selected:{0}&quot;.format(course))
        elif not isinstance(score, float) or score &gt; 100.0 or score &lt; 0.0:
            raise PersonValueError(&quot;Score for Course {0} is Invalid&quot;.format(course))
        self._courses[course] = score

    def scores(self):   #获得一个学生全部课程分数情况
        return [(course,self._courses[course]) for course in self._courses]
</code></pre>
<p>最后是实现教职人员的类，教职人员相比于公共人员类要增加院系，员工号，工资等。操作和学生类是类似的就不再重复了。只是在它的set_salary方法中我看到了一个以前没想到的表达。。</p>
<pre><code class="language-python">if type(amount) is not int:
  xxxxx
#这句判断的意图在于判断所给参数是不是一个合法的int类型，之前没想过直接用is关键字+int类型名就能够进行判断了。。我之前都是这样做的：
if type(amount) is not type(1)：
  xxxxx

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Python】 命名空间与LEGB规则]]></title>
        <id>https://imenghu.github.io/post/python-ming-ming-kong-jian-yu-legb-gui-ze</id>
        <link href="https://imenghu.github.io/post/python-ming-ming-kong-jian-yu-legb-gui-ze">
        </link>
        <updated>2019-11-22T06:39:37.000Z</updated>
        <content type="html"><![CDATA[<p>■　　命名空间</p>
<p>所谓命名空间，就是指根据代码区域的不同而对变量名做出的划分，在一个命名空间中往往会有一定的变量名和变量内容的对应关系。在值语义的语言中，变量名往往是变量所指代内容在内存中地址的别称，但是在python中，变量名本身就是一个字符串对象，命名空间只不过是把这个字符串对象和对象对应了起来。进一步来说，其实在python中的命名空间就是一个字典，记录了该空间中所有变量名和变量内容的对应。后面会提到如何调用这个字典来查看命名空间。</p>
<p>■　　LEGB规则</p>
<p>LEGB是指python中命名空间的四个从低到高不同的层次，分别是Local , Enclosing , Global , Built-in。local指一个函数或者方法的内部的空间，enclosing指的是闭包内部空间，global是整个脚本的全局空间，而built-in是指python最上层的系统自带的一些名字的空间。</p>
<p>因为python可以提供这么多不同层次的命名空间，所以当我们在程序中写下一个变量名的时候，解释器就会通过一定的顺序来查找这个变量名的具体内容。这个顺序显然就是local --&gt; enclosing --&gt; global --&gt; built-in。如果按照此顺序逐级而上却没有找到相关的变量名的内容的话就表明这个变量名在哪一级命名空间中都不存在，程序就会raise起一个NameError了。</p>
<p>因为命名空间是可以互相嵌套的，所以在程序中如果碰到很多同名的变量的话，很可能会由于命名关系的问题而使得程序不像我们所想得那样运行。</p>
<p>●  local和global命名空间<br>
　　最常见的命名空间的关系是local和global之间的：</p>
<pre><code class="language-python">var = &quot;global var&quot;
def test():
    var = &quot;local var&quot;
    print var
test()
print var
#结果
#local var
#global var

</code></pre>
<p>显而易见，函数def中的var是个局部命名空间中的变量，所以函数中print var时解释器在局部命名空间中就已经找到了相关的变量名。另一方面在函数外面print var的时候，此时的var属于程序的global命名空间中且其下面的小命名空间中没有相关的变量名定义，最终解释器只能到global命名空间之中去找到这个变量名。假如把函数中的var = &quot;local var&quot;给注释掉那么显然结果会变成两行的global var因为在函数里面的时候解释器也一直到global的命名空间中才找到变量名。另一方面，如果确实想要在函数中对全局变量var做出一定修改的话那么可以用global关键字来声明某个变量必须查找global的命名空间而不是其下层的命名空间。比如：</p>
<pre><code class="language-python">var = &quot;global var&quot;
def test():
    global var
    var = &quot;local var&quot;
    print var
test()
print var
#结果
#local var
#local var
</code></pre>
<p>因为对于解释器来说，下层的命名空间可以覆盖上层命名空间的内容，而同一层级的命名空间中新的内容又可以覆盖旧的变量的内容，所以在实际工作中要注意到命名空间的变化问题。比如在from module import *这种操作的时候就要当心，因为把一个模块中所有变量名导入到全局命名空间中有可能会把目前存在于命名空间中的一些同名变量给覆盖掉的。</p>
<p>● enclosing命名空间<br>
　　闭包空间在local和global之间，主要用于在面向函数编程的过程中出现的闭包的情况。比如下面这段代码：</p>
<pre><code class="language-python">var = 'global value'
def outer():
    var = 'enclosed value'
    def inner():
        var = 'local value'
        print(var)
    inner()
outer()
#结果
#local value
</code></pre>
<p>如果把var = 'local value'这句给注释掉那么结果就变成了enclosed value，进一步把var = 'enclosed value'也注释掉那结果就变成了global value了。这一切看起来都是显而易见的。</p>
<p>和global命名空间类似的，位于enclosed命名空间包裹中的变量名也可以通过关键字来指定其不搜索local，而直接搜索enclosed级别的命名空间。这个关键字是nonlocal。nonlocal目前只能在python3.x中使用，python2.x还不能使用。</p>
<p>●  built-in命名空间<br>
python自带很多函数和变量，这些对象的名字都是属于内建命名空间的。假如我们想要自定义一个重名的变量，那么就会对内建空间的变量做出覆盖。比如我可以自定义一个len函数来覆盖掉python原本的len函数。虽然可以这么做，但是不推荐，私自覆盖built-in命名空间的内容可能会引起意想不到的后果，比如在后续的函数调用中可能在我们想不到的某个第三方库中调用了len函数的话就会引起混乱了。</p>
<p>●  命名空间内容的查看<br>
python自带了locals()和globals()两个函数，分别返回调用此函数的当前位置所在的local命名空间中所有变量名和值的关系（以字典的形式）以及global命名空间中所有变量名和值的关系。例如：</p>
<pre><code class="language-python">var1 = 1
def test():
    var2 = 2
    print locals()
    print globals()
test()
#结果
#{'var2': 2}
#{'var1': 1, '__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__file__': 'D:/PycharmProjects/TestProject/test.py', '__package__': None, 'test': &lt;function test at 0x000000000383FB38&gt;, '__name__': '__main__', '__doc__': None}
</code></pre>
<p>■　　一些补充</p>
<p>以上说到的包括命名空间也好，LEGB规则也好，借助常识和在其他语言中得到的知识，在实际应用过程中稍微脑补一下总还是能解决的。但是python中有时候也有一些出人意料的情况（至少目前对我来说是这样，我还没办法找到清晰自洽的说法来解释这些出人意料）。下面针对这些情况做出说明，这也是这篇文章的重要之处。</p>
<p>●  不要轻易到下层命名空间中去改变全局变量的值<br>
　　虽然前面说到了，通过global关键字的提前声明可以在函数中也对全局变量做出修改，但是这不是很好。会引起很多乱七八糟的错误，解决的一个方法是通过函数参数的形式把全局变量的值传递到函数中来，然后返回通过函数处理后的值。函数定义结束后回到global命名空间之后在调用函数，以返回值赋值给全局变量：</p>
<pre><code class="language-ptthon">var = 1
def test():
  global var
  var = 2
test()
####上面这样不好，改成下面这样####
var = 1
def test(para):
  para = 2
  return para
var = test(var)
</code></pre>
<p>●  赋值语句的默认行为<br>
　　下面这段代码会报错：</p>
<pre><code class="language-python">var = 1
def test():
    var += 1
test()

#错误信息
#UnboundLocalError: local variable 'var' referenced before assignment
</code></pre>
<p>在一般认知中，var += 1等价于 var = var + 1，这个认识没有问题。但是在python中,赋值语句的默认行为是“只要在当前local命名空间中无同名变量且没有global,nonlocal等关键字的声明的话，就一定创建一个该名字的新局部变量”，然后在进行赋值语句等号右边的运算，把运算所得对象约束到这个局部变量上来。在这个例子中，新建了一个名为var的局部变量，因为var这个名字已经存在于当前的local命名空间中了所以解释器不会再向上层命名空间中去寻找变量。但是这个var在此时还没有具体的对象约束，所以在等号右边运算时导致报错。</p>
<p>如果把上述代码中的var += 1换成var + 1，没有了赋值操作的话，解释器就不会认为var是个新建出来的局部变量，然后查找到全局变量var取它的值来进行运算，这样就不报错了。</p>
<p>另外，如果把var换成另外一种可以通过非赋值手段来改变的类型的话（其实换句话说，就是所有可变类型）：</p>
<pre><code class="language-python">var = [1]
def test():
    var.append(2)
test()
print var
#结果
#[1,2]
</code></pre>
<p>这样子的话，由于避开了创建一个新局部变量的步骤，就可以做到改变全局变量而不报错了。</p>
<p>进一步，一个比较容易混淆的，就是把上面这个例子中的append方法再改成var[0] += 1。这样一个语句乍一看还是一个赋值语句，似乎还是会报错，但是实际上并不。因为它的等号左边不是一个变量名了，通过这个变量名创建一个新局部变量也就无从谈起了。因为它没有办法创建新局部变量，所以也就不会有等号右边变量名存在却没有实际值的变量引起的计算错误了。所以var[0] += 1这个语句最终还是会改变全局变量的var，var从[1]变成了[2]。</p>
<p>●  类中命名空间的特殊性<br>
　　以上说到的命名空间规则，基本上都是在面向函数编程的这个前提下的，在面向对象的编程中，有时候也会遇到一些奇奇怪怪的，类似于命名空间的问题。实际上这些问题应该是属于面向对象机制框架中的一些规律。关于这方面的一些内容我写了一点在python类机制那篇文章中，这里做一点补充。</p>
<p>比如类变量和实例变量之间的命名冲突问题：</p>
<pre><code class="language-python">class Test():
  var = 1
  def __init__(self):
    self.var = 2

t = Test()
print t.var
</code></pre>
<p>在这种情况下因为实例变量存在，所以引用var属性的时候取到的是实例变量的var。但是如果在初始化方法中没有提到self.var的话，那么t.var就直接取向类变量的var。</p>
<p>另一方面，如果在没有实例变量var的情况下，在其他属性方法（除了__init__方法的其他方法）中引用self.var则会指向类变量的var。在有实例变量var的情况下，其他属性方法中的self.var自然是指向实例属性var的。如果实例变量var存在时想要引用类变量var可以通过类名Test.var来引用或者self.<strong>class</strong>.var来引用。</p>
<p>想要提到一点类中命名空间比较特殊的一点，如果把上例代码中的self.var = 2改成self.var += 1，从形式上来说似乎和之前提到过没有用global关键字声明而直接对全局变量进行赋值操作的样子差不多，当时那个情况的结果是报错UnboundLocalError。但是在这里，并不报错。一来，等号左边的self.var本身不是一个变量名，就好比之前提到的var[0] += 1一样，不会创建新的局部变量；二来，在类的属性方法中似乎有一种特别的机制就是会自动把赋值语句等号左边的self.xxx识别成当前实例的一个属性，如果之前没有这个属性就自动创建一个新属性，基于这种推断，在类中的赋值语句中，等号左边如果是self.xxx的话，创建的不是一个新的局部变量而是一个新的实例的属性。从结果来看，这里发生的，是等号右边self.var取到类变量的var，进行+1操作之后赋值给一个新的实例变量的var，自此之后通过这个初始化方法得到的实例就有了一个self.var的实例变量，其值是类变量var+1。由于这种混乱出现的可能，所以在类的方法中想要引用类变量的话请尽量通过类名来引用。比如上面提到的self.var += 1改成Test.var += 1就可以做到每个实例创建后类变量var都+1。</p>
<p>●  for循环的变量名会污染外部命名空间<br>
　　在c，java里面，for循环的第一子句中可以声明一个仅限本次循环使用的变量比如for(int i,i=0;i&lt;10;i++)这样子，再循环结束之后这个i所占的空间就被释放了。</p>
<p>python中这个for表达式更加简洁 for i in range(10)，但是这里的i是会影响本次循环之后的代码的。也就是说在pythonfor循环语句的循环头中的那个变量不是循环语句中的局部变量，而是会泄露到外部命名空间中的变量：</p>
<pre><code class="language-python">for i in range(10):
    if i == 9:
        print locals()
print locals()
#结果
#{'__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__file__': 'D:/PycharmProjects/TestProject/test.py', '__package__': None, 'i': 9, '__name__': '__main__', '__doc__': None}
#{'__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__file__': 'D:/PycharmProjects/TestProject/test.py', '__package__': None, 'i': 9, '__name__': '__main__', '__doc__': None}
</code></pre>
<p>第二个locals函数返回的命名空间信息中依然存在i是9这一项，表明i这个变量被泄露了出来，污染了外部的命名空间。这点需要注意一下。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[浅谈Python类命名空间]]></title>
        <id>https://imenghu.github.io/post/qian-tan-python-lei-ming-ming-kong-jian</id>
        <link href="https://imenghu.github.io/post/qian-tan-python-lei-ming-ming-kong-jian">
        </link>
        <updated>2019-11-21T11:25:52.000Z</updated>
        <content type="html"><![CDATA[<p>前面章节中，已经不只一次提到，所有位于 class 语句中的代码，其实都位于特殊的命名空间中，通常称之为类命名空间。Python 中，编写的整个程序默认处于全局命名空间内，而类体则处于类命名空间内。</p>
<p>Python 允许在全局范围内放置可执行代码，当 Python 执行该程序时，这些代码就会获得执行的机会。类似地，Python 同样允许在类范围内放置可执行代码，当 Python 执行该类定义肘，这些代码同样会获得执行的机会。</p>
<p>例如，如下程序测试了类命名空间：<br>
class Item:</p>
<h1 id="直接在类空间中放置执行性质代码">直接在类空间中放置执行性质代码</h1>
<p>print('正在定义Item类')<br>
for i inrange(10):<br>
if i %2==0:<br>
print('偶数:', i)<br>
else:<br>
print('奇数:', i)<br>
运行结果为：<br>
正在定义Item类<br>
偶数: 0<br>
奇数: 1<br>
偶数: 2<br>
奇数: 3<br>
偶数: 4<br>
奇数: 5<br>
偶数: 6<br>
奇数: 7<br>
偶数: 8<br>
奇数: 9<br>
正如从上面代码所看到的，程序直接在 Item 类体中放置普通的输出语句、循环语句、分支语句，这都是合法的。当程序执行 Item 类时，Item 类命名空间中的这些代码都会被执行。</p>
<p>从执行效果来看，这些可执行代码被放在 Python 类命名空间与全局空间并没有太大的区别。确实如此，这是因为程序并没有定义“成员”（变量或函数），这些代码执行之后就完了，不会留下什么。</p>
<p>但下面代码就有区别。下面代码示范了在全局空间和类命名空间内分别定义 lambda 表达式：<br>
global_fn =lambda p:print('执行lambda表达式，p参数: ', p)<br>
class Category:<br>
cate_fn =lambda p:print('执行lambda表达式，p参数: ', p)</p>
<h1 id="调用全局范围内的global_fn为参数p传入参数值">调用全局范围内的global_fn，为参数p传入参数值</h1>
<p>global_fn('fkit')# ①<br>
c =Category()</p>
<h1 id="调用类命名空间内的cate_fnpython自动绑定第一个参数">调用类命名空间内的cate_fn，Python自动绑定第一个参数</h1>
<p>c.cate_fn()# ②<br>
上面程序分别在全局空间、类命名空间内定义了两个 lambda 表达式，在全局空间内定义的 lambda 表达式就相当于一个普通函数，因此程序使用调用函数的方式来调用该 lambda 表达式，并显式地为第一个参数绑定参数值，如上面程序中 ① 号代码所示。</p>
<p>对于在类命名空间内定义的 lambda 表达式，则相当于在该类命名空间中定义了一个函数，这个函数就变成了实例方法，因此程序必须使用调用方法的方式来调用该 lambda 表达式，Python 同样会为该方法的第一个参数（相当于 self 参数）绑定参数值，如上面程序中 ② 号代码所示。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[解读Python编程中的命名空间与作用域]]></title>
        <id>https://imenghu.github.io/post/jie-du-python-bian-cheng-zhong-de-ming-ming-kong-jian-yu-zuo-yong-yu</id>
        <link href="https://imenghu.github.io/post/jie-du-python-bian-cheng-zhong-de-ming-ming-kong-jian-yu-zuo-yong-yu">
        </link>
        <updated>2019-11-21T11:20:16.000Z</updated>
        <content type="html"><![CDATA[<p>变量是拥有匹配对象的名字（标识符）。命名空间是一个包含了变量名称们（键）和它们各自相应的对象们（值）的字典。<br>
一个Python表达式可以访问局部命名空间和全局命名空间里的变量。如果一个局部变量和一个全局变量重名，则局部变量会覆盖全局变量。<br>
每个函数都有自己的命名空间。类的方法的作用域规则和通常函数的一样。<br>
Python会智能地猜测一个变量是局部的还是全局的，它假设任何在函数内赋值的变量都是局部的。<br>
因此，如果要给全局变量在一个函数里赋值，必须使用global语句。<br>
global VarName的表达式会告诉Python， VarName是一个全局变量，这样Python就不会在局部命名空间里寻找这个变量了。</p>
<p>命名空间的定义<br>
Python命名空间是名称到对象的映射，这就像是字典，键名是变量名，值是变量的值。比如：</p>
<blockquote>
<blockquote>
<blockquote>
<p>x = 3<br>
globals()<br>
{'<strong>builtins</strong>': &lt;module '<strong>builtin</strong>' (built-in)&gt;, '<strong>name</strong>': '<strong>main</strong>', '<strong>doc</strong>': None, 'x': 3, '<strong>package</strong>': None}</p>
</blockquote>
</blockquote>
</blockquote>
<p>可以看到变量x，3以字典的形式存放在globals空间内。以之对应的名字空间还有：locals()。</p>
<blockquote>
<blockquote>
<blockquote>
<p>locals()<br>
{'<strong>builtins</strong>': &lt;module '<strong>builtin</strong>' (built-in)&gt;, '<strong>name</strong>': '<strong>main</strong>', '<strong>doc</strong>': None, 'x': 3, '<strong>package</strong>': None}</p>
</blockquote>
</blockquote>
</blockquote>
<p>实际上，你可以通过向名字添加键名和值：</p>
<blockquote>
<blockquote>
<blockquote>
<p>globals()['y'] = 5<br>
y<br>
5</p>
</blockquote>
</blockquote>
</blockquote>
<p>上图左侧是内置命名空间，右侧是不同的模块，有各自的全局命名空间，全局命名空间内定义函数就会有局部命名空间。</p>
<p>命名空间的种类<br>
Python中有三种命名空间：</p>
<p>a) 局部，函数内的命名空间就是局部的；<br>
b) 全局，模块内的命名空间就是全局的；</p>
<p>c) 内置，包括异常类型、内建函数和特殊方法，可以代码中任意地方调用；<br>
下面讨论关于名字空间的搜索顺序，先来看张图：</p>
<figure data-type="image" tabindex="1"><img src="https://img2.mukewang.com/5af99a370001f46803670254.jpg" alt=""></figure>
<p>命名空间的可见性（作用域）</p>
<p>a) 内置命名空间在代码所有位置都是可见的，所以可以随时被调用；</p>
<p>b) 全局命名空间和局部命名空间中， 如果有同名变量，在全局命名空间处，局部命名空间内的同名变量是不可见的；</p>
<p>c) 在局部命名空间处，全局命名空间的同名变量是不可见的（只有变量不同名的情况下，可使用 global关键字让其可见）。</p>
<p>知道了可见性，下面说变量的查找顺序就要清楚多了。</p>
<p>命名空间的查找顺序<br>
a) 如果在函数内调用一个变量，先在函数内（局部命名空间）查找，如果找到则停止查找。否则在函数外部（全局命名空间）查找，如果还是没找到，则查找内置命名空间。如果以上三个命名都未找到，则抛出NameError 的异常错误。<br>
b) 如果在函数外调用一个变量，则在函数外查找（全局命名空间，局部命名空间此时不可见），如果找到则停止查找，否则到内置命名空间中查找。如果两者都找不到，则抛出异常。只有当局部命名空间内，使用global 关键字声明了一个变量时，查找顺序则是 a) 的查找顺序。</p>
<p>为了帮助理解，来举个例子，我们在全局命名空间里定义一个变量money。我们再在函数内给变量money赋值，然后Python会假定money是一个局部变量。然而，我们并没有在访问前声明一个局部变量money，结果就是会出现一个UnboundLocalError的错误。取消global语句的注释就能解决这个问题。</p>
<p>#!/usr/bin/python</p>
<h1 id="-coding-utf-8-">-<em>- coding: UTF-8 -</em>-</h1>
<p>Money = 2000<br>
def AddMoney():</p>
<h1 id="想改正代码就取消以下注释">想改正代码就取消以下注释:</h1>
<h1 id="global-money">global Money</h1>
<p>Money = Money + 1</p>
<p>print Money<br>
AddMoney()<br>
print Money</p>
<p>dir()函数<br>
dir()函数一个排好序的字符串列表，内容是一个模块里定义过的名字。<br>
返回的列表容纳了在一个模块里定义的所有模块，变量和函数。如下一个简单的实例：<br>
#!/usr/bin/python</p>
<h1 id="-coding-utf-8--2">-<em>- coding: UTF-8 -</em>-</h1>
<h1 id="导入内置math模块">导入内置math模块</h1>
<p>import math</p>
<p>content = dir(math)</p>
<p>print content;</p>
<p>以上实例输出结果：<br>
['<strong>doc</strong>', '<strong>file</strong>', '<strong>name</strong>', 'acos', 'asin', 'atan',<br>
'atan2', 'ceil', 'cos', 'cosh', 'degrees', 'e', 'exp',<br>
'fabs', 'floor', 'fmod', 'frexp', 'hypot', 'ldexp', 'log',<br>
'log10', 'modf', 'pi', 'pow', 'radians', 'sin', 'sinh',<br>
'sqrt', 'tan', 'tanh']</p>
<p>在这里，特殊字符串变量__name__指向模块的名字，__file__指向该模块的导入文件名。</p>
<p>globals()和locals()函数</p>
<pre><code>根据调用地方的不同，globals()和locals()函数可被用来返回全局和局部命名空间里的名字。
如果在函数内部调用locals()，返回的是所有能在该函数里访问的命名。
如果在函数内部调用globals()，返回的是所有在该函数里能访问的全局名字。
两个函数的返回类型都是字典。所以名字们能用keys()函数摘取。
</code></pre>
<p>reload()函数<br>
当一个模块被导入到一个脚本，模块顶层部分的代码只会被执行一次。<br>
因此，如果你想重新执行模块里顶层部分的代码，可以用reload()函数。该函数会重新导入之前导入过的模块。语法如下：<br>
reload(module_name) 厦工叉车<br>
在这里，module_name要直接放模块的名字，而不是一个字符串形式。比如想重载hello模块，如下：<br>
reload(hello)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[windows常用cmd命令]]></title>
        <id>https://imenghu.github.io/post/windows-chang-yong-cmd-ming-ling</id>
        <link href="https://imenghu.github.io/post/windows-chang-yong-cmd-ming-ling">
        </link>
        <updated>2019-11-21T08:47:29.000Z</updated>
        <content type="html"><![CDATA[<p>windows常用cmd命令</p>
<ul>
<li>常用基本命令</li>
<li>辅助符号或命令</li>
<li>常用工具</li>
<li>验证考核<br>
常用基本命令：netstat，find，ping，cd，辅助符号或命令：Ctrl+C、cls、|、&gt;、向上的箭头键等，常用工具: Process Explorer。</li>
</ul>
<p>建议掌握这些命令获取帮助的方式，一般都是 ”命令 /?“ 或者“命令 -help”，如“cd /?”，能看懂命令帮助提示(根据帮助尝试使用)。</p>
<p>常用基本命令<br>
1，列出所有任务及进程号，杀进程</p>
<pre><code> tasklist

 tasklist /?  获取使用帮助

 taskkill

 taskkill /?  获取使用帮助
</code></pre>
<p>2，cd 切换目录</p>
<pre><code> cd /？ 获取使用帮助

 跳转到当前驱动器的根目录

      cd [当前驱动器盘符]:\    例如： cd c:\ ，或者更简单的   cd\

 跳转到当前驱动器的其他文件夹

      以C盘下的WINDOWS文件夹为例，输入：cd C:\WINDOWS

 跳转到其他驱动器

      以从C盘跳转到D盘为例 在任意目录下直接输入：  D:

 跳转到其他驱动器的其他文件夹

      假设当前在C盘，要跳转到E的software目录    cd /d e:\software

      注意此处必须加/d参数。否则无法跳转。

 跳转到上一层目录

      cd..
</code></pre>
<p>3，netstat 查看网络连接状态</p>
<pre><code> 显示协议统计信息和当前 TCP/IP 网络连接。该命令可以查看当前机器建立的所有网络链接状态，以及对应哪个进程。

 netstat -help 获取命令行使用帮助信息

 例子:netstat -ano  查看网络连接、状态以及对应的进程id
</code></pre>
<p>4，find</p>
<pre><code> 常用于某个命令输出结果太多，需要模糊搜索我们关心的内容时使用，一般辅助|使用（|代表前一个输出作为后一个的输入）

 find /？获取使用帮助

 如果是linux就是grep，搜索特定字符

 例子：netstat -ano|find &quot;.8&quot;
</code></pre>
<p>5，ping</p>
<pre><code> ping -help
</code></pre>
<p>6，tracert</p>
<pre><code> tracert也被称为Windows路由跟踪实用程序，在命令提示符（cmd）中使用tracert命令可以用于确定IP数据包访问目标时所选择的路径。

 tracert /? 获取使用帮助

 例子：tracert www.baidu.com
</code></pre>
<p>辅助符号或命令<br>
7，“|”cmd命令中|代表前一个的输出代表后一个的输入</p>
<pre><code> 查找特定ip的网络连接及进程号：netstat -ano|find &quot;192.168.1.10&quot;  
</code></pre>
<p>8，重定向输出符号&gt; &gt;&gt;</p>
<pre><code> 将原本输出到命令窗口的内容，转存到文件中，如jstack 12912 &gt;d:/s.txt  打印线程到指定文件

 cmd &gt;重定向输出并覆盖源文件。

      例如

      echo hello &gt;c:\1.txt

      1.txt的文件内容先被清空，然后写入hello。

 cmd &gt;&gt;重定向输出追加到文件末尾

      例如：

      echo hello &gt;c:\1.txt

      在1.txt文件末尾加上hello
</code></pre>
<p>9，重定向输入符号&lt; &lt;&lt;</p>
<pre><code> cmd &lt; file

      使cmd命令从file读入

 cmd &lt;&lt; text

      从命令行读取输入，直到一个与text相同的行结束。除非使用引号把输入括起来，此模式将对输入内容进行shell变量替换。如果使用 &lt;&lt;- ，则会忽略接下来输入行首的tab，结束行也可以是一堆tab再加上一个与text相同的内容，可以参考后面的例子。

 cmd &lt;&lt;&lt; word

      把word（而不是文件word）和后面的换行作为输入提供给cmd。

 cmd &lt;&gt; file

      以读写模式把文件file重定向到输入，文件file不会被破坏。仅当应用程序利用了这一特性时，它才是有意义的。

 cmd &gt;| file

      功能同&gt;，但即便在设置了noclobber时也会覆盖file文件，注意用的是|而非一些书中说的!，目前仅在csh中仍沿用&gt;!实现这一功能。 
</code></pre>
<p>10，终止一直在运行的命令ctrl+c</p>
<pre><code> 有时某个命令一直打印输出结果(如ping 192.168.1.10 -t)，我们想终止这个命令的执行，直接按ctrl+c即可。
</code></pre>
<p>11，清空cmd窗口内容命令cls</p>
<pre><code> 有时cmd内容太多，滚动费尽，需要清空屏幕内容，直接输入cls即可
</code></pre>
<p>12，cmd命令中，按键盘的向上箭头可以直接复制前一个命令</p>
<p>常用工具<br>
13，常用工具</p>
<pre><code> Process Explorer，查询进程的详细信息，如查询java进程启动参数，运行环境，线程信息、网络连接信息、使用了哪些dll，打开了什么句柄。包含注册表、Socket、文件等等。

 下载地址：https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://imenghu.github.io/post-images/1574326094006.png" alt=""></figure>
<p>验证考核<br>
1，浏览器访问任何一个域名网站（如百度），然后使用cmd命令查找到本机到这个网站的网络连接状态</p>
<pre><code> 2，持续ping100次www.baidu.com,并且输出到d:/pingbaidu.txt

 3，假如不通过环境变量中的java相关命令如jps、java， 而是希望使用你机器上装的某个版本jdk中命令jstack.exe（如装在D:\Program Files\java\jdk1.8.0_101），你会怎么做？

 4，你机器上已经启动了一个smartbi，请告知如何确认jvm所有启动参数</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[javascript 作用域详解]]></title>
        <id>https://imenghu.github.io/post/javascript-zuo-yong-yu-xiang-jie</id>
        <link href="https://imenghu.github.io/post/javascript-zuo-yong-yu-xiang-jie">
        </link>
        <updated>2019-11-19T06:58:14.000Z</updated>
        <content type="html"><![CDATA[<p>作用域理解：定义的变量、函数生效的范围。javascript 有全局作用域和函数作用域两种。</p>
<p>注：es6实现let 块级作用域不是js原生的，底层同样是通过var实现的。如果想了解具体细节，请访问babel官方 对es6中let 进行解析。</p>
<p>执行上下文<br>
范围：一段内或者一个函数内；<br>
全局：函数声明、变量声明 。范围：；<br>
函数：函数声明、变量声明、this、arguments。范围：一个函数内部；</p>
<p><strong>函数、变量声明提升</strong></p>
<pre><code class="language-javascript">&lt;script&gt;

        foo(); //打印a

        var foo = 1;

        function foo (){

            console.log(’a‘)

        }；

        console.log(foo); //1

&lt;/script&gt;

//实际的执行顺序为

&lt;script&gt;

        function foo(){  //函数声明优先于变量的声明

            console.log(&quot;a&quot;);

        }

        //var a ;  重复声明，这儿被省略了。

        foo(); //打印a

        foo = 1;  //给foo赋值为1

        console.log(foo); //1

&lt;/script&gt;
</code></pre>
<p>当js引擎执行一个 执行上下文代码块时，执行顺序为：</p>
<ol>
<li>函数声明 function a(){};(函数优先) 注：let a = function (){}; 这是变量的声明和赋值，不是函数的声明。</li>
<li>变量声明 var a; 注：刚开始只对变量进行声明，没有进行赋值，如果 在赋值之前使用到这个变量 值为：undefined。</li>
<li>执行上下文为函数作用域时：确定this和arguments。</li>
<li>按照js单线程和异步策略依次执行 作用域中的代码。</li>
</ol>
<p>我们习惯将 var a = 2; 看作一个声明，而实际上 JavaScript 引擎并不这么认为。它将 var a和 a = 2 当作两个单独的声明，第一个是编译阶段的任务，而第二个则是执行阶段的任务。这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的最顶端，这个过程被称为提升。要注意避免重复声明，特别是当普通的 var 声明和函数声明混合在一起的时候，否则会引起很多危险的问题！</p>
<p><strong>作用域链</strong><br>
自由变量：当前作用域没有定义的变量，但是上层作用域定义了，可以在此层作用域中使用的变量。<br>
作用域链：当使用一个变量时候，先在自己的作用域里找，如果没有找到，再到父级作用域找，一直找到全局作用域，如果都没有找到即报错。</p>
<p><strong>块级作用域</strong><br>
js无块级作用域，仅有全局作用域和函数作用域两种作用域。<br>
ES6 通过对全局作用域的特殊实现，实现了js的块级作用域 let；<br>
let 的生效范围为 { }；<br>
const 为定义常量。注：定义的常量的值存储的内存地址不可变动，值是可变的比如常量中定义的是数组 或者对象时候，可以通过数组或对象方法操作原数据，只要不重新赋值就没问题</p>
<center>-END-</center>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python中的类属性和对象属性的作用域]]></title>
        <id>https://imenghu.github.io/post/python-zhong-de-lei-shu-xing-he-dui-xiang-shu-xing-de-zuo-yong-yu</id>
        <link href="https://imenghu.github.io/post/python-zhong-de-lei-shu-xing-he-dui-xiang-shu-xing-de-zuo-yong-yu">
        </link>
        <updated>2019-11-19T04:58:47.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://imenghu.github.io/post-images/1574139587626.png" alt=""></figure>
<pre><code class="language-python">class Test:
    num=100 
    def __init__(self):
        self.age=18     

test1=Test()
test2=Test()
print(test1.num)    
test1.num=200  
&quot;&quot;&quot;
只是修改了这个对象作用域下的属性    
类中的num不会发生改变
&quot;&quot;&quot;
print(test1.num)   
print(Test.num)    
del test1.num       
print(test1.num)
</code></pre>
<p>def __init__方法的作用域限制在实例化出的对象<br>
self.age=18<br>
这里的age属性是对象的特有属性，类访问不到<br>
跟 p=person()<br>
p.age=18<br>
是一样的效果<br>
只有p能访问到这个age，person访问不到<br>
如果person中也有这个age，是在两个区域，互不影响<br>
除非在p中的age属性删除之后，p会向person中找相关的属性</p>
<pre><code class="language-python">class a:
    def __init__(self):
        self.name=&quot;a&quot;
        self.age=12
        self.score=23
    def test():
        print(&quot;类方法测试&quot;)
print(a.name)
&quot;&quot;&quot;
这里会报错，因为def __init__构造函数之内的属性只能通过
实例化对象之后，通过对象进行访问，类没有办法直接访问
如果是对象中再增加属性，或者修改属性的值，这些都跟类的属性没有关系
因为两种属性是在两个区域内创建的
&quot;&quot;&quot;
a.test()
</code></pre>
<p>对于类：</p>
<ol>
<li>
<p>类可以直接访问类属性</p>
</li>
<li>
<p>类不可以直接访问实例方法，必须通过实例化之后的对象来访问实例方法</p>
</li>
<li>
<p>类不可以访问对象特有的属性（比如：def __init__中定义的属性）</p>
</li>
<li>
<p>类可以直接访问类方法</p>
</li>
<li>
<p>类可以直接访问静态方法</p>
</li>
</ol>
<p>所以存在：如果对象中的属性跟类中的属性相同，改变对象中的属性值，不会影响类中的属性值</p>
<p>对于对象：</p>
<ol>
<li>
<p>对象可以直接访问类的属性（实例化过程中，类已经将属性赋给对象）</p>
</li>
<li>
<p>对象可以直接访问自己私有的属性</p>
</li>
<li>
<p>对象可以直接访问类方法</p>
</li>
<li>
<p>对象可以直接访问静态方法</p>
</li>
<li>
<p>对象可以直接访问实例方法</p>
</li>
</ol>
<pre><code class="language-python">class a:
    def __init__(self,name):
        self.name=name
        print(self.name)
    age=&quot;这是类属性&quot;
    def test(self):
        self.name=&quot;name已经修改&quot;
        self.age=&quot;age已经修改&quot;
        print(self.age)
        print(self.name)
a1=a(&quot;这是对象属性&quot;)
print(a.age)
print(a1.name)
print(a1.age)
a1.test()
</code></pre>
<p>这里所有的带有self的方法都是实例方法，只能由对象才能访问到，且实例方法中可以访问对象的属性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C#调用python脚本]]></title>
        <id>https://imenghu.github.io/post/cdiao-yong-python-jiao-ben</id>
        <link href="https://imenghu.github.io/post/cdiao-yong-python-jiao-ben">
        </link>
        <updated>2019-11-14T05:22:27.000Z</updated>
        <content type="html"><![CDATA[<p>只尝试了两种调用方式，第一种只适用于python脚本中不包含第三方模块的情况，第二种针对的是python脚本中包含第三方模块的情况。不管哪种方式，首先都需要安装IronPython。可以在官网下载安装包自行安装后添加引用即可。<br>
C#代码</p>
<pre><code class="language-c#">using IronPython.Hosting;
using Microsoft.Scripting.Hosting;
using System;

namespace CSharpCallPython
{
    class Program
    {
        static void Main(string[] args)
        {
            ScriptEngine pyEngine = Python.CreateEngine();//创建Python解释器对象
            dynamic py = pyEngine.ExecuteFile(@&quot;test.py&quot;);//读取脚本文件
            int[] array = new int[9] { 9, 3, 5, 7, 2, 1, 3, 6, 8 };
            string reStr = py.main(array);//调用脚本文件中对应的函数
            Console.WriteLine(reStr);

            Console.ReadKey();
        }
    }
}
</code></pre>
<p>python代码</p>
<pre><code class="language-python">def main(arr):
    try:
        arr = set(arr)
        arr = sorted(arr)
        arr = arr[0:]
        return str(arr)
    except Exception as err:
        return str(err)
</code></pre>
<p><strong>注意</strong><br>
Q：找不到py文件<br>
A：检查最后执行文件路径，可能需要将文件属性中“复制到输出目录”设置为“始终复制”</p>
<p>Q：py文件方法执行异常<br>
A：检查py文件可否单独执行，如果可以执行，检查执行环境是否为3.x，可能需要py代码降级；如果不可执行，检查是否引用第三方包，第三方是否非全局安装</p>
<p>Tip：目前 IronPython 支持Python模拟运行环境为2.x</p>
<p>结果<br>
<img src="https://imenghu.github.io/post-images/1573709817355.png" alt=""></p>
<p>方式二：适用于python脚本中包含第三方模块的情况</p>
<p>C#代码</p>
<pre><code class="language-c#">using System;
using System.Collections;
using System.Diagnostics;

namespace Test
{
    class Program
    {
        static void Main(string[] args)
        {
            Process p = new Process();
            string path = &quot;reset_ipc.py&quot;;//待处理python文件的路径，本例中放在debug文件夹下
            string sArguments = path;
            ArrayList arrayList = new ArrayList();
            arrayList.Add(&quot;com4&quot;);
            arrayList.Add(57600);
            arrayList.Add(&quot;password&quot;);
            foreach (var param in arrayList)//添加参数
            {
                sArguments += &quot; &quot; + sigstr;
            }

            p.StartInfo.FileName = @&quot;D:\Python2\python.exe&quot;; //python2.7的安装路径
            p.StartInfo.Arguments = sArguments;//python命令的参数
            p.StartInfo.UseShellExecute = false;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.RedirectStandardInput = true;
            p.StartInfo.RedirectStandardError = true;
            p.StartInfo.CreateNoWindow = true;
            p.Start();//启动进程

            Console.WriteLine(&quot;执行完毕！&quot;);

            Console.ReadKey();
        }
    }
}
</code></pre>
<p>python代码</p>
<pre><code class="language-python"># -*- coding: UTF-8 -*-
import serial
import time

def resetIPC(com, baudrate, password, timeout=0.5):
    ser=serial.Serial(com, baudrate, timeout=timeout)
    flag=True
    try:
        ser.close()
        ser.open()
        ser.write(&quot;\n&quot;.encode(&quot;utf-8&quot;))
        time.sleep(1)
        ser.write(&quot;root\n&quot;.encode(&quot;utf-8&quot;))
        time.sleep(1)
        passwordStr=&quot;%s\n&quot; % password
        ser.write(passwordStr.encode(&quot;utf-8&quot;))
        time.sleep(1)
        ser.write(&quot;killall -9 xxx\n&quot;.encode(&quot;utf-8&quot;))
        time.sleep(1)
        ser.write(&quot;rm /etc/xxx/xxx_user.*\n&quot;.encode(&quot;utf-8&quot;))
        time.sleep(1)
        ser.write(&quot;reboot\n&quot;.encode(&quot;utf-8&quot;))
        time.sleep(1)
    except Exception:
        flag=False
    finally:
        ser.close()
    return flag

resetIPC(sys.argv[1], sys.argv[2], sys.argv[3])
</code></pre>
<p>上面的python脚本实现的是重启IPC设备，测试功能成功。</p>
<p><strong>调用包含第三方模块的python脚本时，尝试过使用path.append()方式，调试有各种问题，最终放弃了，没有研究。</strong></p>
<p><a href="https://github.com/imenghu/CSharpCallPython.git">git地址</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[getattr,setattr,hasattr详解]]></title>
        <id>https://imenghu.github.io/post/getattrsetattrhasattr-xiang-jie</id>
        <link href="https://imenghu.github.io/post/getattrsetattrhasattr-xiang-jie">
        </link>
        <updated>2019-11-13T01:25:12.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li><strong>hasattr(object, name)</strong></li>
</ol>
<p>判断一个对象里面是否有name属性或者name方法，返回BOOL值，有name特性返回True， 否则返回False。<br>
需要注意的是name要用括号括起来。</p>
<p>实例：<br>
<img src="https://img-blog.csdn.net/20181015192304290?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvdGVtYW4xMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<ol start="2">
<li><strong>getattr(object, name[,default])</strong></li>
</ol>
<p>获取对象object的属性或者方法，如果存在打印出来，如果不存在，打印出默认值，默认值可选。<br>
需要注意的是，如果是返回的对象的方法，返回的是方法的内存地址，如果需要运行这个方法，<br>
可以在后面添加一对括号。</p>
<p>实例：<br>
<img src="https://img-blog.csdn.net/20181015192352956?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvdGVtYW4xMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<ol start="3">
<li><strong>setattr(object, name, values)</strong></li>
</ol>
<p>给对象的属性赋值，若属性不存在，先创建再赋值。<br>
<img src="https://img-blog.csdn.net/20181015192503188?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JvdGVtYW4xMjM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python 中的两个函数dir,help]]></title>
        <id>https://imenghu.github.io/post/python-zhong-de-liang-ge-han-shu</id>
        <link href="https://imenghu.github.io/post/python-zhong-de-liang-ge-han-shu">
        </link>
        <updated>2019-11-12T01:57:04.000Z</updated>
        <content type="html"><![CDATA[<p><strong>1. dir(对象名) 查看该对象的属性和方法。</strong><br>
<strong>2. help(对象名.属性名)  查看该对象属性(方法)的具体实现</strong><br>
<strong>3. print(C.<strong>mro</strong>) MRO 是 method resolution order，主要用于 在多继承时判断 方法、属性 的调用 路径</strong></p>
]]></content>
    </entry>
</feed>