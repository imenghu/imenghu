<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://imenghu.github.io</id>
    <title>i萌虎</title>
    <updated>2019-11-07T05:20:21.379Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://imenghu.github.io"/>
    <link rel="self" href="https://imenghu.github.io/atom.xml"/>
    <logo>https://imenghu.github.io/images/avatar.png</logo>
    <icon>https://imenghu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, i萌虎</rights>
    <entry>
        <title type="html"><![CDATA[函数作用域的LEGB顺序]]></title>
        <id>https://imenghu.github.io/post/han-shu-zuo-yong-yu-de-legb-shun-xu</id>
        <link href="https://imenghu.github.io/post/han-shu-zuo-yong-yu-de-legb-shun-xu">
        </link>
        <updated>2019-11-07T05:19:14.000Z</updated>
        <content type="html"><![CDATA[<p>1.什么是LEGB？<br>
L:local 函数内部作用域<br>
E:enclosing 函数内部与内嵌函数之间<br>
G:global 全局作用域<br>
B:build-in 内置作用域</p>
<p>2.它们是作什么用的<br>
为什么非要介绍这个呢?或者说它们的作用是什么?<br>
原因是因为我们的在学习Python函数的时候，经常会遇到很多定义域的问题，全部变量，内部变量，内部嵌入的函数，等等，Python是如何查找的呢？以及Python又是按照什么顺序来查找的呢？这里做一个顺序的说明</p>
<p>3.顺序是什么<br>
跟名字一样，Python在函数里面的查找分为4种，称之为LEGB，也正是按照这种顺序来查找的。</p>
<p>首先，是local,先查找函数内部<br>
然后，是enclosing，再查找函数内部与嵌入函数之间（是指在函数内部再次定义一个函数）<br>
其次，是global，查找全局<br>
最后，是build-in，内置作用域</p>
<p>4.举例说明<br>
ex1</p>
<p>复制代码<br>
1 passline = 60<br>
2<br>
3 def func(val):<br>
4     if val &gt;= passline:<br>
5         print('pass')<br>
6     else:<br>
7         print('failed')<br>
8<br>
9 func(89)<br>
10<br>
11 ''''''''''''<br>
12 pass<br>
13 [Finished in 0.2s]<br>
14 ''''''''''''<br>
复制代码</p>
<p>Python函数首先查找local，在局部变量作用域里并没有passline的定义，然后发现函数内部并没有内嵌函数，这时Python开始查找global，在全局里查找到passline的定义，被调用。</p>
<p>ex2</p>
<p>复制代码<br>
1 def Max(val1, val2):<br>
2     return max(val1, val2)<br>
3<br>
4 print(Max(90, 100))<br>
5<br>
6 '''''''''<br>
7 100<br>
8 [Finished in 0.1s]<br>
9 '''''''''<br>
复制代码</p>
<p>Max函数里面直接调用另外一个函数，调用的max()（注意两个函数的大小写不一样）,该函数并没有被定义，但是却属于我们上述的第四种，属于build-in函数，既是在python标准库里的函数，内置的，可以直接调用的。最后一步才会查找到这里</p>
<p>关于第二种，属于内嵌函数，即使在函数里面再次定义一个函数，这时会首先查找local函数里面是否有定义，然后才会查找函数里面内嵌函数里面有没有定义，这一种有专门的名词，叫做闭包，闭包将在另外文章里专门写到</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 中类的作用域问题]]></title>
        <id>https://imenghu.github.io/post/python-zhong-lei-de-zuo-yong-yu-wen-ti</id>
        <link href="https://imenghu.github.io/post/python-zhong-lei-de-zuo-yong-yu-wen-ti">
        </link>
        <updated>2019-11-07T03:30:28.000Z</updated>
        <content type="html"><![CDATA[<p>今天写一段小代码的时候犯傻了，我试图在类中的方法内部直接访问类中的变量，大概是这样写的：</p>
<pre><code class="language-python">class Test:
    a = 1

    def __init__(self):
        print(a)

t = Test()

</code></pre>
<p>&quot;&quot;&quot;<br>
NameError: name 'a' is not defined<br>
&quot;&quot;&quot;<br>
很显然报了 NameError 错误，我错误地认为 <strong>init</strong> 方法里面是可以直接拿到类中定义的变量 a 的，实际上并不可以。<br>
如大家所知，Python 的作用域查找顺序是 LEGB，即局部作用域、外部作用域、全局作用域和内置作用域，这里面并不包含 C（类作用域）。<br>
下面引用来自《Python 学习手册》第 859 页的一段话来说明这一点：</p>
<p>** 尽管类能够访问外层函数的作用域，但它们不能作为类中其它代码的外层作用域：Python 搜索外层函数来访问被引用的名称，但从来不会搜索外层类。也就是说，类是一个可以访问其外层作用域的局部作用域，但其本身却不能作为一个外层作用域被访问。因为方法函数中对名称的搜索跳过了外层的类，所以类属性必须作为对象属性并使用继承来访问。***</p>
<p>所以在上面如果要访问到 a 的话，只能通过点号取属性访问，比如 self.<strong>class</strong>.a。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[sql语句之case when null 解决方法]]></title>
        <id>https://imenghu.github.io/post/sql-yu-ju-zhi-case-when-null-jie-jue-fang-fa</id>
        <link href="https://imenghu.github.io/post/sql-yu-ju-zhi-case-when-null-jie-jue-fang-fa">
        </link>
        <updated>2019-11-06T10:51:34.000Z</updated>
        <content type="html"><![CDATA[<p>//判断空值,成功!!<br>
select case<br>
when 项目名称  IS NULL<br>
then '空值'<br>
when 项目名称 ='北二环'<br>
then 'A'<br>
when 项目名称 ='北三环'<br>
then 'B'<br>
else 'C'<br>
END  项目名称<br>
from   物件设计数量统计表</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[修改python ide 自动补全的间隔时间]]></title>
        <id>https://imenghu.github.io/post/xiu-gai-python-ide-zi-dong-bu-quan-de-jian-ge-shi-jian</id>
        <link href="https://imenghu.github.io/post/xiu-gai-python-ide-zi-dong-bu-quan-de-jian-ge-shi-jian">
        </link>
        <updated>2019-11-04T09:54:07.000Z</updated>
        <content type="html"><![CDATA[<p>修改python ide  自动补全的间隔时间:</p>
<p>改 Python\Python36\Lib\idlelib\ config-extensions.def 的</p>
<p>[AutoComplete]</p>
<p>popupwait= 2000</p>
<p>为:</p>
<p>[AutoComplete]</p>
<p>popupwait= 500</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP请求流程]]></title>
        <id>https://imenghu.github.io/post/http-qing-qiu-liu-cheng</id>
        <link href="https://imenghu.github.io/post/http-qing-qiu-liu-cheng">
        </link>
        <updated>2019-11-01T09:23:42.000Z</updated>
        <content type="html"><![CDATA[<p>名词解析：</p>
<p>1：AppDomain—应用程序域，它是一个应用程序在其中执行的独立环境</p>
<p>2：w3wp.exe和aspnet_wp.exe—IIS6.0/IIS5.0 ASP.NET程序运行的必须进程</p>
<p>3：aspnet_isapi.dll—处理aspx等文件的执行文件</p>
<p>4：Managed Modules—托管模块</p>
<p>5: Handlers—处理程序</p>
<p>一：在操作系统启动的时候 ，IIS首先在HTTP.SYS中注册自己的虚拟路径</p>
<p>1：访问不到的URL或者文件，出现404错误，将错误信息返回给客户端。</p>
<p>2：如果请求可访问的URL，HTTP.SYS将请求交给IIS工作者进程w3wp.exe</p>
<figure data-type="image" tabindex="1"><img src="https://images.cnblogs.com/cnblogs_com/freegarden/clip_image002.gif" alt=""></figure>
<p>二：ISAPI（INTERNET SERVER APPLICATION PROGRAME INTERFACE）</p>
<pre><code>互联网服务器应用程序接口的工作如下：
</code></pre>
<p>1：映射文件与其对应的处理程序</p>
<p>1：从HTTP.SYS获取当期请求的信息，保存在HttpWorkerRequest类中</p>
<p>2：在相互隔离的AppDoamin中加载HttpRuntime</p>
<p>3：调用HttpRunTime的ProcessRequest(HttpWorkerRequest wr)方法</p>
<p>三：当请求进入HttpRunTime后，管道由Managed Modules和Handler组成，由它们处理这个HTTP请求</p>
<ol>
<li>
<p>HttpRuntime将Http请求转交给 HttpApplication，HttpApplication代表着程序员创建的Web应用程序。HttpApplication创建针对此Http请求的 HttpContext对象，这些对象包含了关于此请求的诸多其他对象，主要是HttpRequest、HttpResponse、HttpSessionState等。这些对象在程序中可以通过Page类或者Context类进行访问。、</p>
</li>
<li>
<p>接下来Http请求通过一系列Module，这些Module对Http请求具有完全的控制权。这些Module可以做一些执行某个实际工作前的事情。</p>
</li>
<li>
<p>Http请求经过所有的Module之后，它会被HttpHandler处理。在这一步，执行实际的一些操作，通常也就是.aspx页面所完成的业务逻辑。可能你会觉得在创建.aspx页面并没有体会到这一过程，但是，你一定知道，.aspx 页面继承自Page类，我们看一下Page类的签名： public class Page : TemplateControl, IHttpHandler{ // 代码省略}</p>
</li>
</ol>
<p>4：Handler处理完以后，请求再一次回到Module，此时Module可以做工作之后的事情</p>
<p>四:运行程序员编写的代码完成工作，IIS接收返回的数据流，交给HTTP.SYS，由HTTP.SYS将数据返回给客户端,整个请求完成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 连接sqlserver]]></title>
        <id>https://imenghu.github.io/post/python-lian-jie-sqlserver</id>
        <link href="https://imenghu.github.io/post/python-lian-jie-sqlserver">
        </link>
        <updated>2019-11-01T07:41:31.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-python">import pymssql
class linkDB():
    def linkdb():
        #数据库远程连接
        conn = pymssql.connect(host=&quot;数据库IP地址:端口号&quot;,user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)
        #使用cursor()方法获取操作游标
        cursor = conn.cursor()
        #查询语句
        sql = &quot;这里面是sql语句&quot;
        try:
            cursor.execute(sql)  #游标
            result = cursor.fetchall() #查询
            print(result)
        except:
            print(&quot;连接数据库报错了！&quot;)
        #关闭数据库连接
        conn.close()

if __name__ == '__main__':
    linkDB.linkdb()

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django2.0入门教程:Django常用命令]]></title>
        <id>https://imenghu.github.io/post/django20-ru-men-jiao-cheng-django-chang-yong-ming-ling</id>
        <link href="https://imenghu.github.io/post/django20-ru-men-jiao-cheng-django-chang-yong-ming-ling">
        </link>
        <updated>2019-11-01T06:16:02.000Z</updated>
        <content type="html"><![CDATA[<p>安装Django：	pip install django  指定版本 pip3 install django==2.0</p>
<p>新建项目：	django-admin.py startproject mysite</p>
<p>新建APP :	python manage.py startapp blog</p>
<p>启动：python manage.py runserver 8080</p>
<p>同步或者更改生成 数据库：</p>
<p>python manage.py makemigrations</p>
<p>python manage.py migrate</p>
<p>清空数据库：	python manage.py flush</p>
<p>创建管理员：	python manage.py createsuperuser</p>
<p>修改用户密码： python manage.py changepassword username</p>
<p>Django项目环境终端： python manage.py shell</p>
<p>这个命令和 直接运行 python 进入 shell 的区别是：你可以在这个 shell 里面调用当前项目的 models.py 中的 API，对于操作数据的测试非常方便。</p>
<p>更多关于Django的命令在终端输入：python manage.py 查看</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql数据库使用总结]]></title>
        <id>https://imenghu.github.io/post/mysql-shu-ju-ku-shi-yong-zong-jie</id>
        <link href="https://imenghu.github.io/post/mysql-shu-ju-ku-shi-yong-zong-jie">
        </link>
        <updated>2019-11-01T06:09:48.000Z</updated>
        <content type="html"><![CDATA[<p>本文主要记录一些mysql日常使用的命令，供以后查询。<br>
1.更改root密码<br>
mysqladmin -uroot password 'yourpassword'<br>
2.远程登陆mysql服务器<br>
mysql -uroot -p -h192.168.137.10 -P3306<br>
3.查询数据库<br>
show databases;<br>
4.进入某个数据库<br>
use databasename;<br>
5.列出数据库中的表<br>
show tables;<br>
6.查看某个表全部字段<br>
desc slow_log;<br>
show create table slow_log\G; （不仅可以显示表信息，还可以显示建表语句）<br>
7.查看当前用户<br>
select user();<br>
8.查看当前所在数据库<br>
select database();<br>
9.创建新数据库（可以指定字符集）<br>
create database db1 charset utf8;<br>
10.创建新表<br>
create table t1 (<code>id</code> int(4), <code>name</code> char(40));<br>
11.查看数据库版本<br>
select version();<br>
12.查看数据库状态<br>
show status;         当前会话状态<br>
show global status;  全局数据库状态<br>
show slave status\G;   查看主从数据库状态信息<br>
13.查询数据库参数<br>
show variables;<br>
14.修改数据库参数<br>
show variables like 'max_connect%';<br>
set global max_connect_errors = 1000;（重启数据库会失效，要在配置文件中修改）<br>
15.查看当前数据库队列<br>
show processlist;<br>
16.创建普通用户并授权给某个数据库<br>
grant all on databasename.* to 'user1'@'localhost' identified by '123456';<br>
17.查询表数据<br>
select * from mysql.db;           //查询该表中的所有字段<br>
select count(<em>) from mysql.user;  //count(</em>)表示表中有多少行<br>
select db,user  from mysql.db;    //查询表中的多个字段<br>
select * from mysql.db where host like '10.0.%';在查询语句中可以使用万能匹配 “%”<br>
18.插入一行数据<br>
insert into db1.t1 values (1, 'abc');<br>
19.更改表的某一行数据<br>
update db1.t1 set name='aaa' where id=1;<br>
20.清空表数据<br>
truncate table db1.t1;<br>
21.删除表<br>
drop table db1.t1;<br>
22.清空数据库中的所有表（数据库名是eab12）<br>
mysql -N -s information_schema -e &quot;SELECT CONCAT('TRUNCATE TABLE ',TABLE_NAME,';') FROM TABLES WHERE TABLE_SCHEMA='eab12'&quot; | mysql -f eab12<br>
23.删除数据库<br>
drop database db1;<br>
24.数据库备份<br>
mysqldump  -uroot -p'yourpassword' mysql &gt;/tmp/mysql.sql<br>
25.数据库恢复<br>
mysql -uroot -p'yourpassword' mysql &lt;/tmp/mysql.sql<br>
26.新建普通用户<br>
CREATE USER name IDENTIFIED BY 'ssapdrow';<br>
27.更改普通用户密码<br>
SET PASSWORD FOR name=PASSWORD('fdddfd');<br>
28.查看name用户权限<br>
SHOW GRANTS FOR name;<br>
29.脚本中执行mysql命令<br>
mysql -uuser -ppasswd -e&quot;show databases&quot;<br>
echo &quot;show databases&quot;|mysql -uuser -ppassword<br>
以下是执行大量mysql语句采用的方式<br>
mysql -uuser -hhostname -ppasswd &lt;&lt;EOF<br>
mysql语句<br>
EOF</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解JS闭包]]></title>
        <id>https://imenghu.github.io/post/shen-ru-li-jie-js-bi-bao</id>
        <link href="https://imenghu.github.io/post/shen-ru-li-jie-js-bi-bao">
        </link>
        <updated>2019-10-30T13:17:27.000Z</updated>
        <content type="html"><![CDATA[<p>闭包(closure)是Javacript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>
<p>一、变量的作用域</p>
<p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p>
<p>变量的作用域无非就是两种：全局变量和局部变量。</p>
<p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>
<p>js code:</p>
<pre><code class="language-javascript">var n = 999;

function f1(){

　　console.log(n);

}

f1();　　//999
</code></pre>
<p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>
<p>js code:</p>
<pre><code class="language-javascript">function f1(){

　　var n = 999;

}

console.log(n);　　//error
</code></pre>
<p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量。</p>
<p>js code</p>
<pre><code class="language-javascript">function f1(){

　　n = 999;

}

f1();

console.log(n);　　//999
</code></pre>
<p>二、如何从外部读取局部变量？</p>
<p>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</p>
<p>那就是在函数的内部，再定义一个函数。</p>
<p>js code</p>
<pre><code class="language-javascript">function f1(){

　　n = 999;

　　function f2(){

　　　　console.log(n);　　//999

　　}

}
</code></pre>
<p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量对f1就是不可见的。这就是javascript语言特有的‘链式作用域’结构(chain scope)，子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们就可以在f1外部读取它的内部变量了。</p>
<p>js code</p>
<pre><code class="language-javascript">function f1(){

　　n = 999;

　　function f2(){

　　　　console.log(n);

　　}

　　return f2;

}

var result = f1();　　//返回的是f2函数

result();　　//999
</code></pre>
<p>三、闭包的概念</p>
<p>上一节代码中的f2函数，就是闭包。</p>
<p>闭包就是能够读取其他函数内部变量的函数，函数没有被释放，整条作用域链上的局部变量都将得到保留。</p>
<p>由于在javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成‘定义在一个函数内部的函数’。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接的一座桥梁。</p>
<p>四、闭包的用途</p>
<p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<p>js code</p>
<pre><code class="language-javascript">function f1(){

　　var n = 999;

　　nAdd = function(){

　　　　n += 1;

　　}

　　function f2(){

　　　　console.log(n);

　　}

　　return f2;

}

var result = f1();

result();　　//从函数外部通过闭包f2获取到函数f1内部局部变量的值

nAdd();　　//从函数外部通过闭包修改局部变量n的值

result();　　//再次通过闭包f2获取到函数f1内部局部变量的值
</code></pre>
<p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n 一直保存在内存中，并没有在f1调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，不会再调用结束后，被垃圾回收机制(garbage collection)回收。</p>
<p>这段代码中另一个值得注意的地方，就是‘nAdd=function(){n+=1}’这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数(anonymous function)，而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<p>五、使用闭包的注意点</p>
<p>1&gt;由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法时，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2&gt;闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象(object)使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这时一定要小心，不要随便改变父函数内部变量的值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sql Server中查询当天，最近三天，本周，本月，最近一个月，本季度的数据的sql语句]]></title>
        <id>https://imenghu.github.io/post/sql-server-zhong-cha-xun-dang-tian-zui-jin-san-tian-ben-zhou-ben-yue-zui-jin-yi-ge-yue-ben-ji-du-de-shu-ju-de-sql-yu-ju</id>
        <link href="https://imenghu.github.io/post/sql-server-zhong-cha-xun-dang-tian-zui-jin-san-tian-ben-zhou-ben-yue-zui-jin-yi-ge-yue-ben-ji-du-de-shu-ju-de-sql-yu-ju">
        </link>
        <updated>2019-10-30T12:15:11.000Z</updated>
        <content type="html"><![CDATA[<p>当天：</p>
<pre><code class="language-sql">select * from T_news where datediff(day,addtime,getdate())=0
</code></pre>
<p>最近三天：</p>
<pre><code class="language-sql">select * from T_news where datediff(day,addtime,getdate())&lt;= 2 and datediff(day,addtime,getdate())&gt;= 0
</code></pre>
<p>本周：</p>
<pre><code class="language-sql">select * from T_news WHERE (DATEPART(wk, addtime) = DATEPART(wk, GETDATE())) AND (DATEPART(yy, addtime) = DATEPART(yy, GETDATE()))
注意：此时不能用 datediff 差值为7,因为，datediff只表示间隔数
</code></pre>
<p>本月：</p>
<pre><code class="language-sql">select * from T_news WHERE (DATEPART(yy, addtime) = DATEPART(yy, GETDATE())) AND (DATEPART(mm, addtime) = DATEPART(mm, GETDATE()))
</code></pre>
<p>最近一个月：</p>
<pre><code class="language-sql">select * from T_news WHERE (DATEPART(yy, addtime) = DATEPART(yy, GETDATE())) 
AND ((DATEPART(mm, addtime) = DATEPART(mm, GETDATE())) OR (31-DATEPART(DD,addtime)+DATEPART(DD, GETDATE()))&lt;=31)
</code></pre>
<p>本季度：</p>
<pre><code class="language-sql">select * from T_news where DATEPART(qq, addtime) = DATEPART(qq, GETDATE()) and DATEPART(yy, addtime) = DATEPART(yy, GETDATE())
</code></pre>
]]></content>
    </entry>
</feed>