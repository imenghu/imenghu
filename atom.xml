<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://imenghu.github.io</id>
    <title>i萌虎</title>
    <updated>2019-11-04T09:54:24.246Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://imenghu.github.io"/>
    <link rel="self" href="https://imenghu.github.io/atom.xml"/>
    <logo>https://imenghu.github.io/images/avatar.png</logo>
    <icon>https://imenghu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, i萌虎</rights>
    <entry>
        <title type="html"><![CDATA[修改python ide 自动补全的间隔时间]]></title>
        <id>https://imenghu.github.io/post/xiu-gai-python-ide-zi-dong-bu-quan-de-jian-ge-shi-jian</id>
        <link href="https://imenghu.github.io/post/xiu-gai-python-ide-zi-dong-bu-quan-de-jian-ge-shi-jian">
        </link>
        <updated>2019-11-04T09:54:07.000Z</updated>
        <content type="html"><![CDATA[<p>修改python ide  自动补全的间隔时间:</p>
<p>改 Python\Python36\Lib\idlelib\ config-extensions.def 的</p>
<p>[AutoComplete]</p>
<p>popupwait= 2000</p>
<p>为:</p>
<p>[AutoComplete]</p>
<p>popupwait= 500</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP请求流程]]></title>
        <id>https://imenghu.github.io/post/http-qing-qiu-liu-cheng</id>
        <link href="https://imenghu.github.io/post/http-qing-qiu-liu-cheng">
        </link>
        <updated>2019-11-01T09:23:42.000Z</updated>
        <content type="html"><![CDATA[<p>名词解析：</p>
<p>1：AppDomain—应用程序域，它是一个应用程序在其中执行的独立环境</p>
<p>2：w3wp.exe和aspnet_wp.exe—IIS6.0/IIS5.0 ASP.NET程序运行的必须进程</p>
<p>3：aspnet_isapi.dll—处理aspx等文件的执行文件</p>
<p>4：Managed Modules—托管模块</p>
<p>5: Handlers—处理程序</p>
<p>一：在操作系统启动的时候 ，IIS首先在HTTP.SYS中注册自己的虚拟路径</p>
<p>1：访问不到的URL或者文件，出现404错误，将错误信息返回给客户端。</p>
<p>2：如果请求可访问的URL，HTTP.SYS将请求交给IIS工作者进程w3wp.exe</p>
<figure data-type="image" tabindex="1"><img src="https://images.cnblogs.com/cnblogs_com/freegarden/clip_image002.gif" alt=""></figure>
<p>二：ISAPI（INTERNET SERVER APPLICATION PROGRAME INTERFACE）</p>
<pre><code>互联网服务器应用程序接口的工作如下：
</code></pre>
<p>1：映射文件与其对应的处理程序</p>
<p>1：从HTTP.SYS获取当期请求的信息，保存在HttpWorkerRequest类中</p>
<p>2：在相互隔离的AppDoamin中加载HttpRuntime</p>
<p>3：调用HttpRunTime的ProcessRequest(HttpWorkerRequest wr)方法</p>
<p>三：当请求进入HttpRunTime后，管道由Managed Modules和Handler组成，由它们处理这个HTTP请求</p>
<ol>
<li>
<p>HttpRuntime将Http请求转交给 HttpApplication，HttpApplication代表着程序员创建的Web应用程序。HttpApplication创建针对此Http请求的 HttpContext对象，这些对象包含了关于此请求的诸多其他对象，主要是HttpRequest、HttpResponse、HttpSessionState等。这些对象在程序中可以通过Page类或者Context类进行访问。、</p>
</li>
<li>
<p>接下来Http请求通过一系列Module，这些Module对Http请求具有完全的控制权。这些Module可以做一些执行某个实际工作前的事情。</p>
</li>
<li>
<p>Http请求经过所有的Module之后，它会被HttpHandler处理。在这一步，执行实际的一些操作，通常也就是.aspx页面所完成的业务逻辑。可能你会觉得在创建.aspx页面并没有体会到这一过程，但是，你一定知道，.aspx 页面继承自Page类，我们看一下Page类的签名： public class Page : TemplateControl, IHttpHandler{ // 代码省略}</p>
</li>
</ol>
<p>4：Handler处理完以后，请求再一次回到Module，此时Module可以做工作之后的事情</p>
<p>四:运行程序员编写的代码完成工作，IIS接收返回的数据流，交给HTTP.SYS，由HTTP.SYS将数据返回给客户端,整个请求完成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python 连接sqlserver]]></title>
        <id>https://imenghu.github.io/post/python-lian-jie-sqlserver</id>
        <link href="https://imenghu.github.io/post/python-lian-jie-sqlserver">
        </link>
        <updated>2019-11-01T07:41:31.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-python">import pymssql
class linkDB():
    def linkdb():
        #数据库远程连接
        conn = pymssql.connect(host=&quot;数据库IP地址:端口号&quot;,user=&quot;用户名&quot;,password=&quot;密码&quot;,database=&quot;数据库名&quot;,charset=&quot;utf8&quot;)
        #使用cursor()方法获取操作游标
        cursor = conn.cursor()
        #查询语句
        sql = &quot;这里面是sql语句&quot;
        try:
            cursor.execute(sql)  #游标
            result = cursor.fetchall() #查询
            print(result)
        except:
            print(&quot;连接数据库报错了！&quot;)
        #关闭数据库连接
        conn.close()

if __name__ == '__main__':
    linkDB.linkdb()

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django2.0入门教程:Django常用命令]]></title>
        <id>https://imenghu.github.io/post/django20-ru-men-jiao-cheng-django-chang-yong-ming-ling</id>
        <link href="https://imenghu.github.io/post/django20-ru-men-jiao-cheng-django-chang-yong-ming-ling">
        </link>
        <updated>2019-11-01T06:16:02.000Z</updated>
        <content type="html"><![CDATA[<p>安装Django：	pip install django  指定版本 pip3 install django==2.0</p>
<p>新建项目：	django-admin.py startproject mysite</p>
<p>新建APP :	python manage.py startapp blog</p>
<p>启动：python manage.py runserver 8080</p>
<p>同步或者更改生成 数据库：</p>
<p>python manage.py makemigrations</p>
<p>python manage.py migrate</p>
<p>清空数据库：	python manage.py flush</p>
<p>创建管理员：	python manage.py createsuperuser</p>
<p>修改用户密码： python manage.py changepassword username</p>
<p>Django项目环境终端： python manage.py shell</p>
<p>这个命令和 直接运行 python 进入 shell 的区别是：你可以在这个 shell 里面调用当前项目的 models.py 中的 API，对于操作数据的测试非常方便。</p>
<p>更多关于Django的命令在终端输入：python manage.py 查看</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[mysql数据库使用总结]]></title>
        <id>https://imenghu.github.io/post/mysql-shu-ju-ku-shi-yong-zong-jie</id>
        <link href="https://imenghu.github.io/post/mysql-shu-ju-ku-shi-yong-zong-jie">
        </link>
        <updated>2019-11-01T06:09:48.000Z</updated>
        <content type="html"><![CDATA[<p>本文主要记录一些mysql日常使用的命令，供以后查询。<br>
1.更改root密码<br>
mysqladmin -uroot password 'yourpassword'<br>
2.远程登陆mysql服务器<br>
mysql -uroot -p -h192.168.137.10 -P3306<br>
3.查询数据库<br>
show databases;<br>
4.进入某个数据库<br>
use databasename;<br>
5.列出数据库中的表<br>
show tables;<br>
6.查看某个表全部字段<br>
desc slow_log;<br>
show create table slow_log\G; （不仅可以显示表信息，还可以显示建表语句）<br>
7.查看当前用户<br>
select user();<br>
8.查看当前所在数据库<br>
select database();<br>
9.创建新数据库（可以指定字符集）<br>
create database db1 charset utf8;<br>
10.创建新表<br>
create table t1 (<code>id</code> int(4), <code>name</code> char(40));<br>
11.查看数据库版本<br>
select version();<br>
12.查看数据库状态<br>
show status;         当前会话状态<br>
show global status;  全局数据库状态<br>
show slave status\G;   查看主从数据库状态信息<br>
13.查询数据库参数<br>
show variables;<br>
14.修改数据库参数<br>
show variables like 'max_connect%';<br>
set global max_connect_errors = 1000;（重启数据库会失效，要在配置文件中修改）<br>
15.查看当前数据库队列<br>
show processlist;<br>
16.创建普通用户并授权给某个数据库<br>
grant all on databasename.* to 'user1'@'localhost' identified by '123456';<br>
17.查询表数据<br>
select * from mysql.db;           //查询该表中的所有字段<br>
select count(<em>) from mysql.user;  //count(</em>)表示表中有多少行<br>
select db,user  from mysql.db;    //查询表中的多个字段<br>
select * from mysql.db where host like '10.0.%';在查询语句中可以使用万能匹配 “%”<br>
18.插入一行数据<br>
insert into db1.t1 values (1, 'abc');<br>
19.更改表的某一行数据<br>
update db1.t1 set name='aaa' where id=1;<br>
20.清空表数据<br>
truncate table db1.t1;<br>
21.删除表<br>
drop table db1.t1;<br>
22.清空数据库中的所有表（数据库名是eab12）<br>
mysql -N -s information_schema -e &quot;SELECT CONCAT('TRUNCATE TABLE ',TABLE_NAME,';') FROM TABLES WHERE TABLE_SCHEMA='eab12'&quot; | mysql -f eab12<br>
23.删除数据库<br>
drop database db1;<br>
24.数据库备份<br>
mysqldump  -uroot -p'yourpassword' mysql &gt;/tmp/mysql.sql<br>
25.数据库恢复<br>
mysql -uroot -p'yourpassword' mysql &lt;/tmp/mysql.sql<br>
26.新建普通用户<br>
CREATE USER name IDENTIFIED BY 'ssapdrow';<br>
27.更改普通用户密码<br>
SET PASSWORD FOR name=PASSWORD('fdddfd');<br>
28.查看name用户权限<br>
SHOW GRANTS FOR name;<br>
29.脚本中执行mysql命令<br>
mysql -uuser -ppasswd -e&quot;show databases&quot;<br>
echo &quot;show databases&quot;|mysql -uuser -ppassword<br>
以下是执行大量mysql语句采用的方式<br>
mysql -uuser -hhostname -ppasswd &lt;&lt;EOF<br>
mysql语句<br>
EOF</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[深入理解JS闭包]]></title>
        <id>https://imenghu.github.io/post/shen-ru-li-jie-js-bi-bao</id>
        <link href="https://imenghu.github.io/post/shen-ru-li-jie-js-bi-bao">
        </link>
        <updated>2019-10-30T13:17:27.000Z</updated>
        <content type="html"><![CDATA[<p>闭包(closure)是Javacript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>
<p>一、变量的作用域</p>
<p>要理解闭包，首先必须理解Javascript特殊的变量作用域。</p>
<p>变量的作用域无非就是两种：全局变量和局部变量。</p>
<p>Javascript语言的特殊之处，就在于函数内部可以直接读取全局变量。</p>
<p>js code:</p>
<pre><code class="language-javascript">var n = 999;

function f1(){

　　console.log(n);

}

f1();　　//999
</code></pre>
<p>另一方面，在函数外部自然无法读取函数内的局部变量。</p>
<p>js code:</p>
<pre><code class="language-javascript">function f1(){

　　var n = 999;

}

console.log(n);　　//error
</code></pre>
<p>这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量。</p>
<p>js code</p>
<pre><code class="language-javascript">function f1(){

　　n = 999;

}

f1();

console.log(n);　　//999
</code></pre>
<p>二、如何从外部读取局部变量？</p>
<p>出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。</p>
<p>那就是在函数的内部，再定义一个函数。</p>
<p>js code</p>
<pre><code class="language-javascript">function f1(){

　　n = 999;

　　function f2(){

　　　　console.log(n);　　//999

　　}

}
</code></pre>
<p>在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量对f1就是不可见的。这就是javascript语言特有的‘链式作用域’结构(chain scope)，子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们就可以在f1外部读取它的内部变量了。</p>
<p>js code</p>
<pre><code class="language-javascript">function f1(){

　　n = 999;

　　function f2(){

　　　　console.log(n);

　　}

　　return f2;

}

var result = f1();　　//返回的是f2函数

result();　　//999
</code></pre>
<p>三、闭包的概念</p>
<p>上一节代码中的f2函数，就是闭包。</p>
<p>闭包就是能够读取其他函数内部变量的函数，函数没有被释放，整条作用域链上的局部变量都将得到保留。</p>
<p>由于在javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成‘定义在一个函数内部的函数’。</p>
<p>所以，在本质上，闭包就是将函数内部和函数外部连接的一座桥梁。</p>
<p>四、闭包的用途</p>
<p>闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p>
<p>js code</p>
<pre><code class="language-javascript">function f1(){

　　var n = 999;

　　nAdd = function(){

　　　　n += 1;

　　}

　　function f2(){

　　　　console.log(n);

　　}

　　return f2;

}

var result = f1();

result();　　//从函数外部通过闭包f2获取到函数f1内部局部变量的值

nAdd();　　//从函数外部通过闭包修改局部变量n的值

result();　　//再次通过闭包f2获取到函数f1内部局部变量的值
</code></pre>
<p>在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。这证明了，函数f1中的局部变量n 一直保存在内存中，并没有在f1调用后被自动清除。</p>
<p>为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，不会再调用结束后，被垃圾回收机制(garbage collection)回收。</p>
<p>这段代码中另一个值得注意的地方，就是‘nAdd=function(){n+=1}’这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，而不是局部变量。其次，nAdd的值是一个匿名函数(anonymous function)，而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。</p>
<p>五、使用闭包的注意点</p>
<p>1&gt;由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法时，在退出函数之前，将不使用的局部变量全部删除。</p>
<p>2&gt;闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象(object)使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这时一定要小心，不要随便改变父函数内部变量的值。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sql Server中查询当天，最近三天，本周，本月，最近一个月，本季度的数据的sql语句]]></title>
        <id>https://imenghu.github.io/post/sql-server-zhong-cha-xun-dang-tian-zui-jin-san-tian-ben-zhou-ben-yue-zui-jin-yi-ge-yue-ben-ji-du-de-shu-ju-de-sql-yu-ju</id>
        <link href="https://imenghu.github.io/post/sql-server-zhong-cha-xun-dang-tian-zui-jin-san-tian-ben-zhou-ben-yue-zui-jin-yi-ge-yue-ben-ji-du-de-shu-ju-de-sql-yu-ju">
        </link>
        <updated>2019-10-30T12:15:11.000Z</updated>
        <content type="html"><![CDATA[<p>当天：</p>
<pre><code class="language-sql">select * from T_news where datediff(day,addtime,getdate())=0
</code></pre>
<p>最近三天：</p>
<pre><code class="language-sql">select * from T_news where datediff(day,addtime,getdate())&lt;= 2 and datediff(day,addtime,getdate())&gt;= 0
</code></pre>
<p>本周：</p>
<pre><code class="language-sql">select * from T_news WHERE (DATEPART(wk, addtime) = DATEPART(wk, GETDATE())) AND (DATEPART(yy, addtime) = DATEPART(yy, GETDATE()))
注意：此时不能用 datediff 差值为7,因为，datediff只表示间隔数
</code></pre>
<p>本月：</p>
<pre><code class="language-sql">select * from T_news WHERE (DATEPART(yy, addtime) = DATEPART(yy, GETDATE())) AND (DATEPART(mm, addtime) = DATEPART(mm, GETDATE()))
</code></pre>
<p>最近一个月：</p>
<pre><code class="language-sql">select * from T_news WHERE (DATEPART(yy, addtime) = DATEPART(yy, GETDATE())) 
AND ((DATEPART(mm, addtime) = DATEPART(mm, GETDATE())) OR (31-DATEPART(DD,addtime)+DATEPART(DD, GETDATE()))&lt;=31)
</code></pre>
<p>本季度：</p>
<pre><code class="language-sql">select * from T_news where DATEPART(qq, addtime) = DATEPART(qq, GETDATE()) and DATEPART(yy, addtime) = DATEPART(yy, GETDATE())
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[别降低对自己的要求，因为会变本加厉]]></title>
        <id>https://imenghu.github.io/post/bie-jiang-di-dui-zi-ji-de-yao-qiu-yin-wei-hui-bian-ben-jia-li</id>
        <link href="https://imenghu.github.io/post/bie-jiang-di-dui-zi-ji-de-yao-qiu-yin-wei-hui-bian-ben-jia-li">
        </link>
        <updated>2019-10-29T03:12:59.000Z</updated>
        <content type="html"><![CDATA[<p>1</p>
<p>相信在生活中，你也有这样的经历：</p>
<p>晚上睡觉前，你拿起手机对自己说就玩几分钟，结果成了几小时；酒席上，朋友给你劝酒，你实在拒绝不了，说只喝一杯，结果就有了第二杯、第三杯，最后大醉而归；和朋友逛街，本打算什么也不买，结果店员给你推荐了一支眉笔，最后你几乎买了一整套化妆品回家……</p>
<p>很多事情就是这样，一旦有了第一个突破口，结果就会一发不可收拾。</p>
<p>曾听过一个故事，讲的是一个小孩偷了一根针，他的母亲觉得只是一根针而已，就没有责怪他。后来他长大了，又不断做出小偷小摸的事情，直到有一次，他偷了金子被关进大牢。他对着母亲大哭：如果我第一次偷针的时候你就严厉地惩罚我，我就不会有今天。</p>
<p>俗话说，千里之堤毁于蚁穴。如果最初的那个小诱惑、小妥协、小毛病没有引起我们的重视，最后它可能就会变成击垮我们的罪魁祸首。</p>
<h2 id="人一旦放任自己第一次就容易有以后的无数次">人，一旦放任自己第一次，就容易有以后的无数次。</h2>
<p>2</p>
<p>生活中，我们很多人都在讲坚持，但真正能做到好好坚持的人却不多。这是为什么呢？</p>
<p>曾坚持过跑步的人都会遇到这种状况：今天太忙，不跑了；今天太累，明天再跑；今天心情不好，不想跑……当有了第一次找借口，让自己放弃坚持，最后往往就会放弃了坚持本身。</p>
<p>但作家村上春树不一样，他说：因为不想跑步，所以要去跑步。因为从未有过一次“偷懒”，所以他坚持跑了几十年。</p>
<p>坚持做一件事情确实很难，因为我们总有不想做的时候，总会给自己找理由，让自己处于轻松舒服的状态。</p>
<h2 id="但即使坚持很难也不要让自己轻易放弃-因为放弃了一次第二次就更容易了">但即使坚持很难，也不要让自己轻易放弃。因为放弃了一次，第二次就更容易了。</h2>
<p>3</p>
<p>曾有这样一项有趣的实验：一位心理学家找来两辆一模一样的汽车，他把其中一辆停在美国加州帕洛阿尔托的中产阶级社区，而另一辆放在相对杂乱的纽约布朗克斯区。</p>
<p>心理学家先把停在布朗克斯那辆车的车牌摘掉，顶棚打开，结果当天那辆车就被偷走了。</p>
<p>而放在帕洛阿尔托的那辆车，一个星期也无人理睬。后来，心理学家用锤子把那辆车的玻璃敲了个大洞。结果仅仅过了几个小时，那辆车也不见了。</p>
<p>以这项实验为基础，有人提出了一个“破窗效应”理论：一间房子如果窗户破了，没有人去修补，隔不久，其他的窗户也会莫名其妙地被人打破；一面墙上如果出现一些涂鸦没有被清洗掉，很快墙上就会布满乱七八糟、不堪入目的东西；在一个很干净的地方，人们会很不好意思扔垃圾，可一旦地上有垃圾出现，人们就会毫不犹豫地随地乱扔垃圾，丝毫不觉得羞愧。</p>
<p>好的东西，人们会尽量保护它；而好的东西一旦有了裂痕，人们往往就会不自觉地放任其变得更坏。</p>
<h2 id="所以不要给自己放任自己的第一次机会不要打破自己的第一扇窗户">所以，不要给自己放任自己的第一次机会，不要打破自己的第一扇窗户。</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一文彻底搞懂python的垃圾回收机制]]></title>
        <id>https://imenghu.github.io/post/yi-wen-che-di-gao-dong-python-de-la-ji-hui-shou-ji-zhi-1</id>
        <link href="https://imenghu.github.io/post/yi-wen-che-di-gao-dong-python-de-la-ji-hui-shou-ji-zhi-1">
        </link>
        <updated>2019-10-28T09:17:36.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-什么是内存管理和垃圾回收">一 、什么是内存管理和垃圾回收</h2>
<p>Python GC主要使用<strong>引用计数（reference counting）<strong>来跟踪和回收垃圾。在引用计数的基础上，通过“<strong>标记-清除</strong>”（mark and sweep）解决容器对象可能产生的循环引用问题，通过</strong>“分代回收”</strong>（generation collection）以空间换时间的方法提高垃圾回收效率。</p>
<p>现在的高级语言如java，c#等，都采用了垃圾收集机制，而不再是c，c++里用户自己管理维护内存的方式。自己管理内存极其自由，可以任意申请内存，但如同一把双刃剑，为大量内存泄露，悬空指针等bug埋下隐患。</p>
<p>对于一个字符串、列表、类甚至数值都是对象，且定位简单易用的语言，自然不会让用户去处理如何分配回收内存的问题。</p>
<p>python里也同java一样采用了垃圾收集机制，不过不一样的是:</p>
<p>最关键的一句话：</p>
<p><strong>python采用的是引用计数机制为主，标记-清除和分代收集两种机制为辅的策略</strong></p>
<h2 id="二-引用计数reference-count">二、引用计数——reference count</h2>
<p>PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少.引用计数为0时，该对象生命就结束了。</p>
<p>优点:<br>
1 简单<br>
2 实时性<br>
缺点:</p>
<p>那么关键问题来了，什么时候，引用计数增加1，什么时候引用计数减少1呢？</p>
<p>我们可以通过使用内置的模块**sys.getrefcount(a)**可以查看a对象的引用计数，但是比正常计数大1，因为调用函数的时候传入a，这会让a的引用计数+1。</p>
<p>1、简单实例：<br>
1 维护引用计数消耗资源<br>
2 循环引用——最致命的缺点（后面会定义）<br>
<strong>导致引用计数+1的情况：</strong><br>
1 对象被创建，例如a=23<br>
2 对象被引用，例如b=a<br>
3 对象被作为参数，传入到一个函数中，例如func(a)<br>
4 对象作为一个元素，存储在容器中，例如list1=[a,a]<br>
<strong>导致引用计数-1的情况</strong><br>
1 对象的别名被显式销毁，例如del a<br>
2 对象的别名被赋予新的对象，例如a=24<br>
3 一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）<br>
4 对象所在的容器被销毁，或从容器中删除对象</p>
<pre><code class="language-python">import sys
 
class A:
    pass
 
def func(x):
    print(f'对象a：{sys.getrefcount(x)-1}',end='  ')
    return x
 
#a=123.56
a=A()       #创建对象a
print(f'对象a：{sys.getrefcount(a)-1}')
b=a         #再一次引用对象a
print(f'对象a：{sys.getrefcount(a)-1}，对象b：{sys.getrefcount(b)-1}')
c=func(a)   #对象a作为函数参数
print(f'对象c：{sys.getrefcount(c)-1}')
d=list()    #对象a作为列表元素
d.append(a)
print(f'对象a：{sys.getrefcount(a)-1}，对象d：{sys.getrefcount(d)-1}')
</code></pre>
<p>运行结果为：</p>
<p>对象a：1</p>
<p>对象a：2，对象b：2</p>
<p>对象a：4 ,  对象c：3</p>
<p>对象a：4，对象d：1</p>
<p>==============================================================================================</p>
<p><strong>2、一个小的误区</strong></p>
<pre><code class="language-python">a=100

sys.getrefcount(a)-1
</code></pre>
<p>返回结果为：50</p>
<p>这是为什么呢？</p>
<p>这是因为python系统维护着一个常见的“整数常量池”即-5-255，在这个区间的数字会有其他的处理方式，这说明100这个数字，目前在系统中有 50 个引用。包括字符串也有一些特殊的处理，所以在使用应用技术的时候，最好是使用自己自定义的数据类型，这样方便分析，这也是上面为什么要自定义一个类型A的原因。</p>
<p><strong>3、减少引用的实例</strong></p>
<pre><code class="language-python">import sys
class B:
    pass
 
del d[0]  #删除列表d中的元素a
print(f'对象a：{sys.getrefcount(a)-1}，对象d：{sys.getrefcount(d)-1}')
 
a=B()   # a被重新复制，引用计数为1
print(f'对象a：{sys.getrefcount(a)-1}')
del a   #删除了a
</code></pre>
<p>运行结果为：</p>
<p>对象a：3，对象d：1<br>
对象a：1</p>
<p><strong>4、引用计数的致命缺陷——循环引用导致的内存泄漏</strong></p>
<p>什么是<strong>内存泄漏</strong>呢？</p>
<p>指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。导致程序运行速度减慢甚至系统崩溃等严重后果。有 <strong>del</strong>() 函数的对象间的循环引用是导致内存泄漏的主凶。不使用一个对象时使用:del object 来删除一个对象的引用计数就可以有效防止内存泄漏问题。通过 Python 扩展模块 gc 来查看不能回收的对象的详细信息。可以通过 sys.getrefcount(obj) 来获取对象的引用计数，并根据返回值是否为 0 来判断是否内存泄漏。</p>
<pre><code class="language-python">
def f2():
    while True:
        c1=ClassA()
        c2=ClassA()
        c1.t=c2
        c2.t=c1
        del c1
        del c2

</code></pre>
<p>创建了c1，c2后，0x237cf30（c1对应的内存，记为内存1）,0x237cf58（c2对应的内存，记为内存2）这两块内存的引用计数都是1，执行c1.t=c2和c2.t=c1后，这两块内存的引用计数变成2.</p>
<p>在del c1后，内存1的对象的引用计数变为1，由于不是为0，所以内存1的对象不会被销毁，所以内存2的对象的引用数依然是2，在del c2后，同理，内存1的对象，内存2的对象的引用数都是1。</p>
<p>虽然它们两个的对象都是可以被销毁的，但是由于循环引用，导致垃圾回收器都不会回收它们，所以就会导致内存泄露。</p>
<pre><code class="language-python">list1 = []
list2 = []
list1.append(list2)
list2.append(list1)
</code></pre>
<p>list1与list2相互引用，如果不存在其他对象对它们的引用，list1与list2的引用计数也仍然为1，所占用的内存永远无法被回收，这将是致命的。</p>
<p><strong>5、针对“循环引用”的解决办法</strong></p>
<p><strong>（1）标记清除技术——mark and sweep</strong></p>
<p><strong>（2）分代回收技术——generation collection</strong></p>
<p><strong>（3）手动使用gc模块</strong></p>
<h2 id="二-标记-清除机制mark-and-sweep">二、标记-清除机制——mark and sweep</h2>
<p>基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</p>
<p>针对循环引用的情况：我们有一个“孤岛”或是一组未使用的、互相指向的对象，但是谁都没有外部引用。换句话说，我们的程序不再使用这些节点对象了，所以我们希望Python的垃圾回收机制能够足够智能去释放这些对象并回收它们占用的内存空间。但是这不可能，因为所有的引用计数都是1而不是0。Python的引用计数算法不能够处理互相指向自己的对象。你的代码也许会在不经意间包含循环引用并且你并未意识到。事实上，当你的Python程序运行的时候它将会建立一定数量的“浮点数垃圾”，Python的GC不能够处理未使用的对象因为应用计数值不会到零。</p>
<p>这就是为什么Python要引入Generational GC算法的原因！</p>
<p><strong>『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收。那么GC又是如何判断哪些是活动对象哪些是非活动对象的呢？</strong></p>
<p><strong>对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。</strong></p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20181112111929278.png" alt=""></figure>
<p>在上图中，我们把小黑圈视为全局变量，也就是把它作为root object，从小黑圈出发，对象1可直达，那么它将被标记，对象2、3可间接到达也会被标记，而4和5不可达，那么1、2、3就是活动对象，4和5是非活动对象会被GC回收。</p>
<p>标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。</p>
<h2 id="三-分代技术generation-collection">三、分代技术——generation collection</h2>
<p>分代回收的整体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每个集合就成为一个“代”，垃圾收集频率随着“代”的存活时间的增大而减小，存活时间通常利用经过几次垃圾回收来度量。</p>
<p>Python默认定义了三代对象集合，索引数越大，对象存活时间越长。<br>
分代技术是一种典型的以空间换时间的技术，这也正是java里的关键技术。这种思想简单点说就是：<strong>对象存在时间越长，越可能不是垃圾，应该越少去收集。</strong><br>
这样的思想，可以减少标记-清除机制所带来的额外操作。分代就是将回收对象分成数个代，每个代就是一个链表（集合），代进行标记-清除的时间与代内对象<br>
存活时间成正比例关系。<br>
从上面代码可以看出python里一共有三代，每个代的threshold值表示该代最多容纳对象的个数。默认情况下，当0代超过700,或1，2代超过10，垃圾回收机制将触发。<br>
0代触发将清理所有三代，1代触发会清理1,2代，2代触发后只会清理自己。<br>
举例： 当某些内存块M经过了3次垃圾收集的清洗之后还存活时，我们就将内存块M划到一个集合A中去，而新分配的内存都划分到集合B中去。当垃圾收集开始工作时，大多数情况都只对集合B进行垃圾回收，而对集合A进行垃圾回收要隔相当长一段时间后才进行，这就使得垃圾收集机制需要处理的内存少了，效率自然就提高了。在这个过程中，集合B中的某些内存块由于存活时间长而会被转移到集合A中，当然，集合A中实际上也存在一些垃圾，这些垃圾的回收会因为这种分代的机制而被延迟。</p>
<p>总结：</p>
<p><strong>分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象。</strong></p>
<h2 id="四-垃圾回收与性能调优">四、垃圾回收与性能调优</h2>
<p>1.手动垃圾回收</p>
<p>2.调高垃圾回收阈值</p>
<p>3.避免循环引用（手动解循环引用和使用弱引用）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python大盘点：全局变量、局部变量、类变量、实例变量]]></title>
        <id>https://imenghu.github.io/post/python-da-pan-dian-quan-ju-bian-liang-ju-bu-bian-liang-lei-bian-liang-shi-li-bian-liang</id>
        <link href="https://imenghu.github.io/post/python-da-pan-dian-quan-ju-bian-liang-ju-bu-bian-liang-lei-bian-liang-shi-li-bian-liang">
        </link>
        <updated>2019-10-28T02:51:47.000Z</updated>
        <content type="html"><![CDATA[<p>1、全局变量：在模块内、在所有函数外面、在class外面，这就是全局变量。<br>
2、局部变量：在函数内、在class的方法（构造、类方法、静态方法、实例方法）内（变量未加self修饰），这就是局部变量<br>
3、 静态变量（类变量）：在class内的，但不在class的方法内的，这就是静态变量（类变量）<br>
4、 实例变量：在class的方法内的，用self修饰的变量，这就是实例变量</p>
]]></content>
    </entry>
</feed>